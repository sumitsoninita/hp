"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./services/storageService.ts":
/*!************************************!*\
  !*** ./services/storageService.ts ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addApplication: function() { return /* binding */ addApplication; },\n/* harmony export */   addEvaluationNoteToApplication: function() { return /* binding */ addEvaluationNoteToApplication; },\n/* harmony export */   addUser: function() { return /* binding */ addUser; },\n/* harmony export */   clearAllData: function() { return /* binding */ clearAllData; },\n/* harmony export */   deleteApplication: function() { return /* binding */ deleteApplication; },\n/* harmony export */   getApplicationByStudent: function() { return /* binding */ getApplicationByStudent; },\n/* harmony export */   getApplicationByStudentId: function() { return /* binding */ getApplicationByStudentId; },\n/* harmony export */   getApplications: function() { return /* binding */ getApplications; },\n/* harmony export */   getUserByEmail: function() { return /* binding */ getUserByEmail; },\n/* harmony export */   getUserById: function() { return /* binding */ getUserById; },\n/* harmony export */   getUsers: function() { return /* binding */ getUsers; },\n/* harmony export */   migrateApplicationStudentIds: function() { return /* binding */ migrateApplicationStudentIds; },\n/* harmony export */   updateApplicationStatus: function() { return /* binding */ updateApplicationStatus; }\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/types */ \"(app-pages-browser)/./types.ts\");\n\nconst USERS_KEY = \"fff_users\";\nconst APPLICATIONS_KEY = \"fff_applications\";\nconst MEETINGS_KEY = \"fff_meetings\";\nconst NOTIFICATIONS_KEY = \"fff_notifications\";\n// Check if we're in the browser\nconst isBrowser = \"object\" !== \"undefined\";\n// User Functions\nconst getUsers = ()=>{\n    if (!isBrowser) return [];\n    const users = localStorage.getItem(USERS_KEY);\n    return users ? JSON.parse(users) : [];\n};\nconst getUserByEmail = (email)=>{\n    return getUsers().find((user)=>user.email === email);\n};\nconst getUserById = (id)=>{\n    return getUsers().find((user)=>user.id === id);\n};\nconst addUser = (user)=>{\n    if (!isBrowser) throw new Error(\"Cannot add user on server side\");\n    const users = getUsers();\n    const newUser = {\n        ...user,\n        id: \"user_\".concat(Date.now())\n    };\n    users.push(newUser);\n    localStorage.setItem(USERS_KEY, JSON.stringify(users));\n    return newUser;\n};\n// Application Functions\nconst getApplications = ()=>{\n    if (!isBrowser) return [];\n    const applications = localStorage.getItem(APPLICATIONS_KEY);\n    console.log(\"getApplications - Raw localStorage data:\", applications);\n    const parsed = applications ? JSON.parse(applications) : [];\n    console.log(\"getApplications - Parsed applications:\", parsed);\n    return parsed;\n};\nconst getApplicationByStudentId = (studentId)=>{\n    return getApplications().find((app)=>app.studentId === studentId);\n};\n// Enhanced function to find application by student ID or name (for backward compatibility)\nconst getApplicationByStudent = (studentId, studentName)=>{\n    if (!isBrowser) return undefined;\n    try {\n        const applications = getApplications();\n        console.log(\"getApplicationByStudent - All applications:\", applications);\n        console.log(\"getApplicationByStudent - Looking for studentId:\", studentId, \"studentName:\", studentName);\n        // First try to find by exact student ID\n        let app = applications.find((app)=>app.studentId === studentId);\n        console.log(\"getApplicationByStudent - Found by ID:\", app);\n        // If not found, try to find by student name (for existing applications with different IDs)\n        if (!app) {\n            app = applications.find((app)=>app.studentName === studentName);\n            console.log(\"getApplicationByStudent - Found by name:\", app);\n            // If found by name, update the studentId to match current user\n            if (app) {\n                console.log(\"getApplicationByStudent - Updating studentId from\", app.studentId, \"to\", studentId);\n                app.studentId = studentId;\n                // Save the updated application back to localStorage\n                localStorage.setItem(APPLICATIONS_KEY, JSON.stringify(applications));\n            }\n        }\n        console.log(\"getApplicationByStudent - Final result:\", app);\n        return app;\n    } catch (error) {\n        console.error(\"Error in getApplicationByStudent:\", error);\n        return undefined;\n    }\n};\nconst addApplication = (application)=>{\n    if (!isBrowser) throw new Error(\"Cannot add application on server side\");\n    const applications = getApplications();\n    const newApplication = {\n        ...application,\n        id: \"app_\".concat(Date.now()),\n        status: _types__WEBPACK_IMPORTED_MODULE_0__.ApplicationStatus.SUBMITTED,\n        submissionDate: new Date().toISOString()\n    };\n    applications.push(newApplication);\n    localStorage.setItem(APPLICATIONS_KEY, JSON.stringify(applications));\n    return newApplication;\n};\nconst updateApplicationStatus = (applicationId, status)=>{\n    if (!isBrowser) return undefined;\n    const applications = getApplications();\n    const appIndex = applications.findIndex((app)=>app.id === applicationId);\n    if (appIndex !== -1) {\n        applications[appIndex].status = status;\n        localStorage.setItem(APPLICATIONS_KEY, JSON.stringify(applications));\n        return applications[appIndex];\n    }\n    return undefined;\n};\nconst addEvaluationNoteToApplication = (applicationId, note)=>{\n    if (!isBrowser) return undefined;\n    const applications = getApplications();\n    const appIndex = applications.findIndex((app)=>app.id === applicationId);\n    if (appIndex !== -1) {\n        var _applications_appIndex_notes;\n        // FIX: Explicitly type `newNote` to ensure it matches the EvaluationNote interface.\n        const newNote = {\n            ...note,\n            id: \"note_\".concat(Date.now()),\n            timestamp: new Date().toISOString()\n        };\n        if (!applications[appIndex].notes) {\n            applications[appIndex].notes = [];\n        }\n        (_applications_appIndex_notes = applications[appIndex].notes) === null || _applications_appIndex_notes === void 0 ? void 0 : _applications_appIndex_notes.push(newNote);\n        localStorage.setItem(APPLICATIONS_KEY, JSON.stringify(applications));\n        return applications[appIndex];\n    }\n    return undefined;\n};\nconst deleteApplication = (applicationId)=>{\n    if (!isBrowser) return false;\n    const applications = getApplications();\n    const filteredApplications = applications.filter((app)=>app.id !== applicationId);\n    if (filteredApplications.length < applications.length) {\n        localStorage.setItem(APPLICATIONS_KEY, JSON.stringify(filteredApplications));\n        return true;\n    }\n    return false;\n};\nconst clearAllData = ()=>{\n    if (!isBrowser) return;\n    localStorage.removeItem(USERS_KEY);\n    localStorage.removeItem(APPLICATIONS_KEY);\n    // Re-seed the basic users\n    seedAdmin();\n    seedStudent();\n};\n// Migration function to fix existing applications with mismatched student IDs\nconst migrateApplicationStudentIds = ()=>{\n    if (!isBrowser) return;\n    try {\n        const applications = getApplications();\n        const users = getUsers();\n        let updated = false;\n        applications.forEach((app)=>{\n            // Check if the studentId in the application matches any existing user\n            const userExists = users.find((user)=>user.id === app.studentId);\n            if (!userExists) {\n                // Try to find user by name\n                const userByName = users.find((user)=>user.fullName === app.studentName);\n                if (userByName) {\n                    app.studentId = userByName.id;\n                    updated = true;\n                }\n            }\n        });\n        if (updated) {\n            localStorage.setItem(APPLICATIONS_KEY, JSON.stringify(applications));\n        }\n    } catch (error) {\n        console.error(\"Error in migration:\", error);\n    }\n};\n// Seeding functions (defined after main functions to avoid circular dependency)\nconst seedAdmin = ()=>{\n    if (!isBrowser) return;\n    const users = getUsers();\n    if (!users.some((u)=>u.role === _types__WEBPACK_IMPORTED_MODULE_0__.UserRole.ADMIN)) {\n        const admin = {\n            id: \"admin_01\",\n            email: \"admin@test.com\",\n            password: \"admin123\",\n            role: _types__WEBPACK_IMPORTED_MODULE_0__.UserRole.ADMIN,\n            fullName: \"HP Admin\"\n        };\n        users.push(admin);\n        localStorage.setItem(USERS_KEY, JSON.stringify(users));\n    }\n};\nconst seedStudent = ()=>{\n    if (!isBrowser) return;\n    const users = getUsers();\n    if (!users.some((u)=>u.email === \"student@test.com\")) {\n        const student = {\n            id: \"student_01\",\n            email: \"student@test.com\",\n            password: \"student123\",\n            role: _types__WEBPACK_IMPORTED_MODULE_0__.UserRole.STUDENT,\n            fullName: \"Test Student\",\n            college: \"Test University\"\n        };\n        users.push(student);\n        localStorage.setItem(USERS_KEY, JSON.stringify(users));\n    }\n};\n// Initialize with admin and student (only in browser)\nif (isBrowser) {\n    try {\n        if (!localStorage.getItem(USERS_KEY)) {\n            localStorage.setItem(USERS_KEY, JSON.stringify([]));\n            seedAdmin();\n            seedStudent();\n        } else {\n            // Ensure both users exist even if localStorage already has data\n            seedAdmin();\n            seedStudent();\n        // Run migration to fix any existing application student ID mismatches\n        // Temporarily disabled to fix loading issue\n        // try {\n        //     migrateApplicationStudentIds();\n        // } catch (error) {\n        //     console.error('Migration failed:', error);\n        // }\n        }\n    } catch (error) {\n        console.error(\"Storage service initialization failed:\", error);\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NlcnZpY2VzL3N0b3JhZ2VTZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ3NJO0FBRXRJLE1BQU1FLFlBQVk7QUFDbEIsTUFBTUMsbUJBQW1CO0FBQ3pCLE1BQU1DLGVBQWU7QUFDckIsTUFBTUMsb0JBQW9CO0FBRTFCLGdDQUFnQztBQUNoQyxNQUFNQyxZQUFZLGFBQWtCO0FBRXBDLGlCQUFpQjtBQUNWLE1BQU1DLFdBQVc7SUFDcEIsSUFBSSxDQUFDRCxXQUFXLE9BQU8sRUFBRTtJQUN6QixNQUFNRSxRQUFRQyxhQUFhQyxPQUFPLENBQUNSO0lBQ25DLE9BQU9NLFFBQVFHLEtBQUtDLEtBQUssQ0FBQ0osU0FBUyxFQUFFO0FBQ3pDLEVBQUU7QUFFSyxNQUFNSyxpQkFBaUIsQ0FBQ0M7SUFDM0IsT0FBT1AsV0FBV1EsSUFBSSxDQUFDQyxDQUFBQSxPQUFRQSxLQUFLRixLQUFLLEtBQUtBO0FBQ2xELEVBQUU7QUFFSyxNQUFNRyxjQUFjLENBQUNDO0lBQ3hCLE9BQU9YLFdBQVdRLElBQUksQ0FBQ0MsQ0FBQUEsT0FBUUEsS0FBS0UsRUFBRSxLQUFLQTtBQUMvQyxFQUFFO0FBRUssTUFBTUMsVUFBVSxDQUFDSDtJQUNwQixJQUFJLENBQUNWLFdBQVcsTUFBTSxJQUFJYyxNQUFNO0lBQ2hDLE1BQU1aLFFBQVFEO0lBQ2QsTUFBTWMsVUFBZ0I7UUFBRSxHQUFHTCxJQUFJO1FBQUVFLElBQUksUUFBbUIsT0FBWEksS0FBS0MsR0FBRztJQUFLO0lBQzFEZixNQUFNZ0IsSUFBSSxDQUFDSDtJQUNYWixhQUFhZ0IsT0FBTyxDQUFDdkIsV0FBV1MsS0FBS2UsU0FBUyxDQUFDbEI7SUFDL0MsT0FBT2E7QUFDWCxFQUFFO0FBR0Ysd0JBQXdCO0FBQ2pCLE1BQU1NLGtCQUFrQjtJQUMzQixJQUFJLENBQUNyQixXQUFXLE9BQU8sRUFBRTtJQUN6QixNQUFNc0IsZUFBZW5CLGFBQWFDLE9BQU8sQ0FBQ1A7SUFD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Q0FBQ0MsTUFBTTZELElBQUksQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRXhELEtBQUssS0FBSyxxQkFBcUI7UUFDbEQsTUFBTTZELFVBQWdCO1lBQ2xCekQsSUFBSTtZQUNKSixPQUFPO1lBQ1A0RCxVQUFVO1lBQ1ZILE1BQU12RSw0Q0FBUUEsQ0FBQzRFLE9BQU87WUFDdEJSLFVBQVU7WUFDVlMsU0FBUztRQUNiO1FBQ0FyRSxNQUFNZ0IsSUFBSSxDQUFDbUQ7UUFDWGxFLGFBQWFnQixPQUFPLENBQUN2QixXQUFXUyxLQUFLZSxTQUFTLENBQUNsQjtJQUNuRDtBQUNKO0FBRUEsc0RBQXNEO0FBQ3RELElBQUlGLFdBQVc7SUFDWCxJQUFJO1FBQ0EsSUFBSSxDQUFDRyxhQUFhQyxPQUFPLENBQUNSLFlBQVk7WUFDbENPLGFBQWFnQixPQUFPLENBQUN2QixXQUFXUyxLQUFLZSxTQUFTLENBQUMsRUFBRTtZQUNqRG1DO1lBQ0FDO1FBQ0osT0FBTztZQUNILGdFQUFnRTtZQUNoRUQ7WUFDQUM7UUFDQSxzRUFBc0U7UUFDdEUsNENBQTRDO1FBQzVDLFFBQVE7UUFDUixzQ0FBc0M7UUFDdEMsb0JBQW9CO1FBQ3BCLGlEQUFpRDtRQUNqRCxJQUFJO1FBQ1I7SUFDSixFQUFFLE9BQU94QixPQUFPO1FBQ1pULFFBQVFTLEtBQUssQ0FBQywwQ0FBMENBO0lBQzVEO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc2VydmljZXMvc3RvcmFnZVNlcnZpY2UudHM/ZjQyMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCB7IFVzZXIsIFVzZXJSb2xlLCBTdHVkZW50QXBwbGljYXRpb24sIEFwcGxpY2F0aW9uU3RhdHVzLCBFdmFsdWF0aW9uTm90ZSwgTWVldGluZ1NjaGVkdWxlLCBTdHVkZW50Tm90aWZpY2F0aW9uIH0gZnJvbSAnQC90eXBlcyc7XG5cbmNvbnN0IFVTRVJTX0tFWSA9ICdmZmZfdXNlcnMnO1xuY29uc3QgQVBQTElDQVRJT05TX0tFWSA9ICdmZmZfYXBwbGljYXRpb25zJztcbmNvbnN0IE1FRVRJTkdTX0tFWSA9ICdmZmZfbWVldGluZ3MnO1xuY29uc3QgTk9USUZJQ0FUSU9OU19LRVkgPSAnZmZmX25vdGlmaWNhdGlvbnMnO1xuXG4vLyBDaGVjayBpZiB3ZSdyZSBpbiB0aGUgYnJvd3NlclxuY29uc3QgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8vIFVzZXIgRnVuY3Rpb25zXG5leHBvcnQgY29uc3QgZ2V0VXNlcnMgPSAoKTogVXNlcltdID0+IHtcbiAgICBpZiAoIWlzQnJvd3NlcikgcmV0dXJuIFtdO1xuICAgIGNvbnN0IHVzZXJzID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oVVNFUlNfS0VZKTtcbiAgICByZXR1cm4gdXNlcnMgPyBKU09OLnBhcnNlKHVzZXJzKSA6IFtdO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldFVzZXJCeUVtYWlsID0gKGVtYWlsOiBzdHJpbmcpOiBVc2VyIHwgdW5kZWZpbmVkID0+IHtcbiAgICByZXR1cm4gZ2V0VXNlcnMoKS5maW5kKHVzZXIgPT4gdXNlci5lbWFpbCA9PT0gZW1haWwpO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldFVzZXJCeUlkID0gKGlkOiBzdHJpbmcpOiBVc2VyIHwgdW5kZWZpbmVkID0+IHtcbiAgICByZXR1cm4gZ2V0VXNlcnMoKS5maW5kKHVzZXIgPT4gdXNlci5pZCA9PT0gaWQpO1xufTtcblxuZXhwb3J0IGNvbnN0IGFkZFVzZXIgPSAodXNlcjogT21pdDxVc2VyLCAnaWQnPik6IFVzZXIgPT4ge1xuICAgIGlmICghaXNCcm93c2VyKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhZGQgdXNlciBvbiBzZXJ2ZXIgc2lkZScpO1xuICAgIGNvbnN0IHVzZXJzID0gZ2V0VXNlcnMoKTtcbiAgICBjb25zdCBuZXdVc2VyOiBVc2VyID0geyAuLi51c2VyLCBpZDogYHVzZXJfJHtEYXRlLm5vdygpfWAgfTtcbiAgICB1c2Vycy5wdXNoKG5ld1VzZXIpO1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFVTRVJTX0tFWSwgSlNPTi5zdHJpbmdpZnkodXNlcnMpKTtcbiAgICByZXR1cm4gbmV3VXNlcjtcbn07XG5cblxuLy8gQXBwbGljYXRpb24gRnVuY3Rpb25zXG5leHBvcnQgY29uc3QgZ2V0QXBwbGljYXRpb25zID0gKCk6IFN0dWRlbnRBcHBsaWNhdGlvbltdID0+IHtcbiAgICBpZiAoIWlzQnJvd3NlcikgcmV0dXJuIFtdO1xuICAgIGNvbnN0IGFwcGxpY2F0aW9ucyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKEFQUExJQ0FUSU9OU19LRVkpO1xuICAgIGNvbnNvbGUubG9nKCdnZXRBcHBsaWNhdGlvbnMgLSBSYXcgbG9jYWxTdG9yYWdlIGRhdGE6JywgYXBwbGljYXRpb25zKTtcbiAgICBjb25zdCBwYXJzZWQgPSBhcHBsaWNhdGlvbnMgPyBKU09OLnBhcnNlKGFwcGxpY2F0aW9ucykgOiBbXTtcbiAgICBjb25zb2xlLmxvZygnZ2V0QXBwbGljYXRpb25zIC0gUGFyc2VkIGFwcGxpY2F0aW9uczonLCBwYXJzZWQpO1xuICAgIHJldHVybiBwYXJzZWQ7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0QXBwbGljYXRpb25CeVN0dWRlbnRJZCA9IChzdHVkZW50SWQ6IHN0cmluZyk6IFN0dWRlbnRBcHBsaWNhdGlvbiB8IHVuZGVmaW5lZCA9PiB7XG4gICAgcmV0dXJuIGdldEFwcGxpY2F0aW9ucygpLmZpbmQoYXBwID0+IGFwcC5zdHVkZW50SWQgPT09IHN0dWRlbnRJZCk7XG59O1xuXG4vLyBFbmhhbmNlZCBmdW5jdGlvbiB0byBmaW5kIGFwcGxpY2F0aW9uIGJ5IHN0dWRlbnQgSUQgb3IgbmFtZSAoZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkpXG5leHBvcnQgY29uc3QgZ2V0QXBwbGljYXRpb25CeVN0dWRlbnQgPSAoc3R1ZGVudElkOiBzdHJpbmcsIHN0dWRlbnROYW1lOiBzdHJpbmcpOiBTdHVkZW50QXBwbGljYXRpb24gfCB1bmRlZmluZWQgPT4ge1xuICAgIGlmICghaXNCcm93c2VyKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGFwcGxpY2F0aW9ucyA9IGdldEFwcGxpY2F0aW9ucygpO1xuICAgICAgICBjb25zb2xlLmxvZygnZ2V0QXBwbGljYXRpb25CeVN0dWRlbnQgLSBBbGwgYXBwbGljYXRpb25zOicsIGFwcGxpY2F0aW9ucyk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdnZXRBcHBsaWNhdGlvbkJ5U3R1ZGVudCAtIExvb2tpbmcgZm9yIHN0dWRlbnRJZDonLCBzdHVkZW50SWQsICdzdHVkZW50TmFtZTonLCBzdHVkZW50TmFtZSk7XG4gICAgICAgIFxuICAgICAgICAvLyBGaXJzdCB0cnkgdG8gZmluZCBieSBleGFjdCBzdHVkZW50IElEXG4gICAgICAgIGxldCBhcHAgPSBhcHBsaWNhdGlvbnMuZmluZChhcHAgPT4gYXBwLnN0dWRlbnRJZCA9PT0gc3R1ZGVudElkKTtcbiAgICAgICAgY29uc29sZS5sb2coJ2dldEFwcGxpY2F0aW9uQnlTdHVkZW50IC0gRm91bmQgYnkgSUQ6JywgYXBwKTtcbiAgICAgICAgXG4gICAgICAgIC8vIElmIG5vdCBmb3VuZCwgdHJ5IHRvIGZpbmQgYnkgc3R1ZGVudCBuYW1lIChmb3IgZXhpc3RpbmcgYXBwbGljYXRpb25zIHdpdGggZGlmZmVyZW50IElEcylcbiAgICAgICAgaWYgKCFhcHApIHtcbiAgICAgICAgICAgIGFwcCA9IGFwcGxpY2F0aW9ucy5maW5kKGFwcCA9PiBhcHAuc3R1ZGVudE5hbWUgPT09IHN0dWRlbnROYW1lKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdnZXRBcHBsaWNhdGlvbkJ5U3R1ZGVudCAtIEZvdW5kIGJ5IG5hbWU6JywgYXBwKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gSWYgZm91bmQgYnkgbmFtZSwgdXBkYXRlIHRoZSBzdHVkZW50SWQgdG8gbWF0Y2ggY3VycmVudCB1c2VyXG4gICAgICAgICAgICBpZiAoYXBwKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2dldEFwcGxpY2F0aW9uQnlTdHVkZW50IC0gVXBkYXRpbmcgc3R1ZGVudElkIGZyb20nLCBhcHAuc3R1ZGVudElkLCAndG8nLCBzdHVkZW50SWQpO1xuICAgICAgICAgICAgICAgIGFwcC5zdHVkZW50SWQgPSBzdHVkZW50SWQ7XG4gICAgICAgICAgICAgICAgLy8gU2F2ZSB0aGUgdXBkYXRlZCBhcHBsaWNhdGlvbiBiYWNrIHRvIGxvY2FsU3RvcmFnZVxuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKEFQUExJQ0FUSU9OU19LRVksIEpTT04uc3RyaW5naWZ5KGFwcGxpY2F0aW9ucykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZygnZ2V0QXBwbGljYXRpb25CeVN0dWRlbnQgLSBGaW5hbCByZXN1bHQ6JywgYXBwKTtcbiAgICAgICAgcmV0dXJuIGFwcDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBnZXRBcHBsaWNhdGlvbkJ5U3R1ZGVudDonLCBlcnJvcik7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGFkZEFwcGxpY2F0aW9uID0gKGFwcGxpY2F0aW9uOiBPbWl0PFN0dWRlbnRBcHBsaWNhdGlvbiwgJ2lkJyB8ICdzdGF0dXMnIHwgJ3N1Ym1pc3Npb25EYXRlJz4pOiBTdHVkZW50QXBwbGljYXRpb24gPT4ge1xuICAgIGlmICghaXNCcm93c2VyKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhZGQgYXBwbGljYXRpb24gb24gc2VydmVyIHNpZGUnKTtcbiAgICBjb25zdCBhcHBsaWNhdGlvbnMgPSBnZXRBcHBsaWNhdGlvbnMoKTtcbiAgICBjb25zdCBuZXdBcHBsaWNhdGlvbjogU3R1ZGVudEFwcGxpY2F0aW9uID0ge1xuICAgICAgICAuLi5hcHBsaWNhdGlvbixcbiAgICAgICAgaWQ6IGBhcHBfJHtEYXRlLm5vdygpfWAsXG4gICAgICAgIHN0YXR1czogQXBwbGljYXRpb25TdGF0dXMuU1VCTUlUVEVELFxuICAgICAgICBzdWJtaXNzaW9uRGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgfTtcbiAgICBhcHBsaWNhdGlvbnMucHVzaChuZXdBcHBsaWNhdGlvbik7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oQVBQTElDQVRJT05TX0tFWSwgSlNPTi5zdHJpbmdpZnkoYXBwbGljYXRpb25zKSk7XG4gICAgcmV0dXJuIG5ld0FwcGxpY2F0aW9uO1xufTtcblxuZXhwb3J0IGNvbnN0IHVwZGF0ZUFwcGxpY2F0aW9uU3RhdHVzID0gKGFwcGxpY2F0aW9uSWQ6IHN0cmluZywgc3RhdHVzOiBBcHBsaWNhdGlvblN0YXR1cyk6IFN0dWRlbnRBcHBsaWNhdGlvbiB8IHVuZGVmaW5lZCA9PiB7XG4gICAgaWYgKCFpc0Jyb3dzZXIpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3QgYXBwbGljYXRpb25zID0gZ2V0QXBwbGljYXRpb25zKCk7XG4gICAgY29uc3QgYXBwSW5kZXggPSBhcHBsaWNhdGlvbnMuZmluZEluZGV4KGFwcCA9PiBhcHAuaWQgPT09IGFwcGxpY2F0aW9uSWQpO1xuICAgIGlmIChhcHBJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgYXBwbGljYXRpb25zW2FwcEluZGV4XS5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKEFQUExJQ0FUSU9OU19LRVksIEpTT04uc3RyaW5naWZ5KGFwcGxpY2F0aW9ucykpO1xuICAgICAgICByZXR1cm4gYXBwbGljYXRpb25zW2FwcEluZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbmV4cG9ydCBjb25zdCBhZGRFdmFsdWF0aW9uTm90ZVRvQXBwbGljYXRpb24gPSAoYXBwbGljYXRpb25JZDogc3RyaW5nLCBub3RlOiBPbWl0PEV2YWx1YXRpb25Ob3RlLCAnaWQnIHwgJ3RpbWVzdGFtcCc+KTogU3R1ZGVudEFwcGxpY2F0aW9uIHwgdW5kZWZpbmVkID0+IHtcbiAgICBpZiAoIWlzQnJvd3NlcikgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjb25zdCBhcHBsaWNhdGlvbnMgPSBnZXRBcHBsaWNhdGlvbnMoKTtcbiAgICBjb25zdCBhcHBJbmRleCA9IGFwcGxpY2F0aW9ucy5maW5kSW5kZXgoYXBwID0+IGFwcC5pZCA9PT0gYXBwbGljYXRpb25JZCk7XG4gICAgaWYgKGFwcEluZGV4ICE9PSAtMSkge1xuICAgICAgICAvLyBGSVg6IEV4cGxpY2l0bHkgdHlwZSBgbmV3Tm90ZWAgdG8gZW5zdXJlIGl0IG1hdGNoZXMgdGhlIEV2YWx1YXRpb25Ob3RlIGludGVyZmFjZS5cbiAgICAgICAgY29uc3QgbmV3Tm90ZTogRXZhbHVhdGlvbk5vdGUgPSB7XG4gICAgICAgICAgICAuLi5ub3RlLFxuICAgICAgICAgICAgaWQ6IGBub3RlXyR7RGF0ZS5ub3coKX1gLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFhcHBsaWNhdGlvbnNbYXBwSW5kZXhdLm5vdGVzKSB7XG4gICAgICAgICAgICBhcHBsaWNhdGlvbnNbYXBwSW5kZXhdLm5vdGVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgYXBwbGljYXRpb25zW2FwcEluZGV4XS5ub3Rlcz8ucHVzaChuZXdOb3RlKTtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oQVBQTElDQVRJT05TX0tFWSwgSlNPTi5zdHJpbmdpZnkoYXBwbGljYXRpb25zKSk7XG4gICAgICAgIHJldHVybiBhcHBsaWNhdGlvbnNbYXBwSW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuZXhwb3J0IGNvbnN0IGRlbGV0ZUFwcGxpY2F0aW9uID0gKGFwcGxpY2F0aW9uSWQ6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICAgIGlmICghaXNCcm93c2VyKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgYXBwbGljYXRpb25zID0gZ2V0QXBwbGljYXRpb25zKCk7XG4gICAgY29uc3QgZmlsdGVyZWRBcHBsaWNhdGlvbnMgPSBhcHBsaWNhdGlvbnMuZmlsdGVyKGFwcCA9PiBhcHAuaWQgIT09IGFwcGxpY2F0aW9uSWQpO1xuICAgIGlmIChmaWx0ZXJlZEFwcGxpY2F0aW9ucy5sZW5ndGggPCBhcHBsaWNhdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKEFQUExJQ0FUSU9OU19LRVksIEpTT04uc3RyaW5naWZ5KGZpbHRlcmVkQXBwbGljYXRpb25zKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5leHBvcnQgY29uc3QgY2xlYXJBbGxEYXRhID0gKCk6IHZvaWQgPT4ge1xuICAgIGlmICghaXNCcm93c2VyKSByZXR1cm47XG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oVVNFUlNfS0VZKTtcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShBUFBMSUNBVElPTlNfS0VZKTtcbiAgICAvLyBSZS1zZWVkIHRoZSBiYXNpYyB1c2Vyc1xuICAgIHNlZWRBZG1pbigpO1xuICAgIHNlZWRTdHVkZW50KCk7XG59O1xuXG4vLyBNaWdyYXRpb24gZnVuY3Rpb24gdG8gZml4IGV4aXN0aW5nIGFwcGxpY2F0aW9ucyB3aXRoIG1pc21hdGNoZWQgc3R1ZGVudCBJRHNcbmV4cG9ydCBjb25zdCBtaWdyYXRlQXBwbGljYXRpb25TdHVkZW50SWRzID0gKCk6IHZvaWQgPT4ge1xuICAgIGlmICghaXNCcm93c2VyKSByZXR1cm47XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYXBwbGljYXRpb25zID0gZ2V0QXBwbGljYXRpb25zKCk7XG4gICAgICAgIGNvbnN0IHVzZXJzID0gZ2V0VXNlcnMoKTtcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgXG4gICAgICAgIGFwcGxpY2F0aW9ucy5mb3JFYWNoKGFwcCA9PiB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgc3R1ZGVudElkIGluIHRoZSBhcHBsaWNhdGlvbiBtYXRjaGVzIGFueSBleGlzdGluZyB1c2VyXG4gICAgICAgICAgICBjb25zdCB1c2VyRXhpc3RzID0gdXNlcnMuZmluZCh1c2VyID0+IHVzZXIuaWQgPT09IGFwcC5zdHVkZW50SWQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoIXVzZXJFeGlzdHMpIHtcbiAgICAgICAgICAgICAgICAvLyBUcnkgdG8gZmluZCB1c2VyIGJ5IG5hbWVcbiAgICAgICAgICAgICAgICBjb25zdCB1c2VyQnlOYW1lID0gdXNlcnMuZmluZCh1c2VyID0+IHVzZXIuZnVsbE5hbWUgPT09IGFwcC5zdHVkZW50TmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKHVzZXJCeU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwLnN0dWRlbnRJZCA9IHVzZXJCeU5hbWUuaWQ7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBpZiAodXBkYXRlZCkge1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oQVBQTElDQVRJT05TX0tFWSwgSlNPTi5zdHJpbmdpZnkoYXBwbGljYXRpb25zKSk7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBtaWdyYXRpb246JywgZXJyb3IpO1xuICAgIH1cbn07XG5cbi8vIFNlZWRpbmcgZnVuY3Rpb25zIChkZWZpbmVkIGFmdGVyIG1haW4gZnVuY3Rpb25zIHRvIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY3kpXG5jb25zdCBzZWVkQWRtaW4gPSAoKSA9PiB7XG4gICAgaWYgKCFpc0Jyb3dzZXIpIHJldHVybjtcbiAgICBcbiAgICBjb25zdCB1c2VycyA9IGdldFVzZXJzKCk7XG4gICAgaWYgKCF1c2Vycy5zb21lKHUgPT4gdS5yb2xlID09PSBVc2VyUm9sZS5BRE1JTikpIHtcbiAgICAgICAgY29uc3QgYWRtaW46IFVzZXIgPSB7XG4gICAgICAgICAgICBpZDogJ2FkbWluXzAxJyxcbiAgICAgICAgICAgIGVtYWlsOiAnYWRtaW5AdGVzdC5jb20nLFxuICAgICAgICAgICAgcGFzc3dvcmQ6ICdhZG1pbjEyMycsXG4gICAgICAgICAgICByb2xlOiBVc2VyUm9sZS5BRE1JTixcbiAgICAgICAgICAgIGZ1bGxOYW1lOiAnSFAgQWRtaW4nXG4gICAgICAgIH07XG4gICAgICAgIHVzZXJzLnB1c2goYWRtaW4pO1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShVU0VSU19LRVksIEpTT04uc3RyaW5naWZ5KHVzZXJzKSk7XG4gICAgfVxufTtcblxuY29uc3Qgc2VlZFN0dWRlbnQgPSAoKSA9PiB7XG4gICAgaWYgKCFpc0Jyb3dzZXIpIHJldHVybjtcbiAgICBcbiAgICBjb25zdCB1c2VycyA9IGdldFVzZXJzKCk7XG4gICAgaWYgKCF1c2Vycy5zb21lKHUgPT4gdS5lbWFpbCA9PT0gJ3N0dWRlbnRAdGVzdC5jb20nKSkge1xuICAgICAgICBjb25zdCBzdHVkZW50OiBVc2VyID0ge1xuICAgICAgICAgICAgaWQ6ICdzdHVkZW50XzAxJyxcbiAgICAgICAgICAgIGVtYWlsOiAnc3R1ZGVudEB0ZXN0LmNvbScsXG4gICAgICAgICAgICBwYXNzd29yZDogJ3N0dWRlbnQxMjMnLFxuICAgICAgICAgICAgcm9sZTogVXNlclJvbGUuU1RVREVOVCxcbiAgICAgICAgICAgIGZ1bGxOYW1lOiAnVGVzdCBTdHVkZW50JyxcbiAgICAgICAgICAgIGNvbGxlZ2U6ICdUZXN0IFVuaXZlcnNpdHknXG4gICAgICAgIH07XG4gICAgICAgIHVzZXJzLnB1c2goc3R1ZGVudCk7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFVTRVJTX0tFWSwgSlNPTi5zdHJpbmdpZnkodXNlcnMpKTtcbiAgICB9XG59O1xuXG4vLyBJbml0aWFsaXplIHdpdGggYWRtaW4gYW5kIHN0dWRlbnQgKG9ubHkgaW4gYnJvd3NlcilcbmlmIChpc0Jyb3dzZXIpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoIWxvY2FsU3RvcmFnZS5nZXRJdGVtKFVTRVJTX0tFWSkpIHtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFVTRVJTX0tFWSwgSlNPTi5zdHJpbmdpZnkoW10pKTtcbiAgICAgICAgICAgIHNlZWRBZG1pbigpO1xuICAgICAgICAgICAgc2VlZFN0dWRlbnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEVuc3VyZSBib3RoIHVzZXJzIGV4aXN0IGV2ZW4gaWYgbG9jYWxTdG9yYWdlIGFscmVhZHkgaGFzIGRhdGFcbiAgICAgICAgICAgIHNlZWRBZG1pbigpO1xuICAgICAgICAgICAgc2VlZFN0dWRlbnQoKTtcbiAgICAgICAgICAgIC8vIFJ1biBtaWdyYXRpb24gdG8gZml4IGFueSBleGlzdGluZyBhcHBsaWNhdGlvbiBzdHVkZW50IElEIG1pc21hdGNoZXNcbiAgICAgICAgICAgIC8vIFRlbXBvcmFyaWx5IGRpc2FibGVkIHRvIGZpeCBsb2FkaW5nIGlzc3VlXG4gICAgICAgICAgICAvLyB0cnkge1xuICAgICAgICAgICAgLy8gICAgIG1pZ3JhdGVBcHBsaWNhdGlvblN0dWRlbnRJZHMoKTtcbiAgICAgICAgICAgIC8vIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyAgICAgY29uc29sZS5lcnJvcignTWlncmF0aW9uIGZhaWxlZDonLCBlcnJvcik7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdTdG9yYWdlIHNlcnZpY2UgaW5pdGlhbGl6YXRpb24gZmFpbGVkOicsIGVycm9yKTtcbiAgICB9XG59Il0sIm5hbWVzIjpbIlVzZXJSb2xlIiwiQXBwbGljYXRpb25TdGF0dXMiLCJVU0VSU19LRVkiLCJBUFBMSUNBVElPTlNfS0VZIiwiTUVFVElOR1NfS0VZIiwiTk9USUZJQ0FUSU9OU19LRVkiLCJpc0Jyb3dzZXIiLCJnZXRVc2VycyIsInVzZXJzIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsIkpTT04iLCJwYXJzZSIsImdldFVzZXJCeUVtYWlsIiwiZW1haWwiLCJmaW5kIiwidXNlciIsImdldFVzZXJCeUlkIiwiaWQiLCJhZGRVc2VyIiwiRXJyb3IiLCJuZXdVc2VyIiwiRGF0ZSIsIm5vdyIsInB1c2giLCJzZXRJdGVtIiwic3RyaW5naWZ5IiwiZ2V0QXBwbGljYXRpb25zIiwiYXBwbGljYXRpb25zIiwiY29uc29sZSIsImxvZyIsInBhcnNlZCIsImdldEFwcGxpY2F0aW9uQnlTdHVkZW50SWQiLCJzdHVkZW50SWQiLCJhcHAiLCJnZXRBcHBsaWNhdGlvbkJ5U3R1ZGVudCIsInN0dWRlbnROYW1lIiwidW5kZWZpbmVkIiwiZXJyb3IiLCJhZGRBcHBsaWNhdGlvbiIsImFwcGxpY2F0aW9uIiwibmV3QXBwbGljYXRpb24iLCJzdGF0dXMiLCJTVUJNSVRURUQiLCJzdWJtaXNzaW9uRGF0ZSIsInRvSVNPU3RyaW5nIiwidXBkYXRlQXBwbGljYXRpb25TdGF0dXMiLCJhcHBsaWNhdGlvbklkIiwiYXBwSW5kZXgiLCJmaW5kSW5kZXgiLCJhZGRFdmFsdWF0aW9uTm90ZVRvQXBwbGljYXRpb24iLCJub3RlIiwibmV3Tm90ZSIsInRpbWVzdGFtcCIsIm5vdGVzIiwiZGVsZXRlQXBwbGljYXRpb24iLCJmaWx0ZXJlZEFwcGxpY2F0aW9ucyIsImZpbHRlciIsImxlbmd0aCIsImNsZWFyQWxsRGF0YSIsInJlbW92ZUl0ZW0iLCJzZWVkQWRtaW4iLCJzZWVkU3R1ZGVudCIsIm1pZ3JhdGVBcHBsaWNhdGlvblN0dWRlbnRJZHMiLCJ1cGRhdGVkIiwiZm9yRWFjaCIsInVzZXJFeGlzdHMiLCJ1c2VyQnlOYW1lIiwiZnVsbE5hbWUiLCJzb21lIiwidSIsInJvbGUiLCJBRE1JTiIsImFkbWluIiwicGFzc3dvcmQiLCJzdHVkZW50IiwiU1RVREVOVCIsImNvbGxlZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./services/storageService.ts\n"));

/***/ })

});