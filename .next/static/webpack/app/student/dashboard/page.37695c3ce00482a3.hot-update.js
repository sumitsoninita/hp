"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/student/dashboard/page",{

/***/ "(app-pages-browser)/./services/storageService.ts":
/*!************************************!*\
  !*** ./services/storageService.ts ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addApplication: function() { return /* binding */ addApplication; },\n/* harmony export */   addEvaluationNoteToApplication: function() { return /* binding */ addEvaluationNoteToApplication; },\n/* harmony export */   addUser: function() { return /* binding */ addUser; },\n/* harmony export */   clearAllData: function() { return /* binding */ clearAllData; },\n/* harmony export */   deleteApplication: function() { return /* binding */ deleteApplication; },\n/* harmony export */   getApplicationByStudent: function() { return /* binding */ getApplicationByStudent; },\n/* harmony export */   getApplicationByStudentId: function() { return /* binding */ getApplicationByStudentId; },\n/* harmony export */   getApplications: function() { return /* binding */ getApplications; },\n/* harmony export */   getUserByEmail: function() { return /* binding */ getUserByEmail; },\n/* harmony export */   getUserById: function() { return /* binding */ getUserById; },\n/* harmony export */   getUsers: function() { return /* binding */ getUsers; },\n/* harmony export */   migrateApplicationStudentIds: function() { return /* binding */ migrateApplicationStudentIds; },\n/* harmony export */   updateApplicationStatus: function() { return /* binding */ updateApplicationStatus; }\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/types */ \"(app-pages-browser)/./types.ts\");\n\nconst USERS_KEY = \"fff_users\";\nconst APPLICATIONS_KEY = \"fff_applications\";\n// Check if we're in the browser\nconst isBrowser = \"object\" !== \"undefined\";\n// User Functions\nconst getUsers = ()=>{\n    if (!isBrowser) return [];\n    const users = localStorage.getItem(USERS_KEY);\n    return users ? JSON.parse(users) : [];\n};\nconst getUserByEmail = (email)=>{\n    return getUsers().find((user)=>user.email === email);\n};\nconst getUserById = (id)=>{\n    return getUsers().find((user)=>user.id === id);\n};\nconst addUser = (user)=>{\n    if (!isBrowser) throw new Error(\"Cannot add user on server side\");\n    const users = getUsers();\n    const newUser = {\n        ...user,\n        id: \"user_\".concat(Date.now())\n    };\n    users.push(newUser);\n    localStorage.setItem(USERS_KEY, JSON.stringify(users));\n    return newUser;\n};\n// Application Functions\nconst getApplications = ()=>{\n    if (!isBrowser) return [];\n    const applications = localStorage.getItem(APPLICATIONS_KEY);\n    return applications ? JSON.parse(applications) : [];\n};\nconst getApplicationByStudentId = (studentId)=>{\n    return getApplications().find((app)=>app.studentId === studentId);\n};\n// Enhanced function to find application by student ID or name (for backward compatibility)\nconst getApplicationByStudent = (studentId, studentName)=>{\n    if (!isBrowser) return undefined;\n    try {\n        const applications = getApplications();\n        console.log(\"getApplicationByStudent - All applications:\", applications);\n        console.log(\"getApplicationByStudent - Looking for studentId:\", studentId, \"studentName:\", studentName);\n        // First try to find by exact student ID\n        let app = applications.find((app)=>app.studentId === studentId);\n        console.log(\"getApplicationByStudent - Found by ID:\", app);\n        // If not found, try to find by student name (for existing applications with different IDs)\n        if (!app) {\n            app = applications.find((app)=>app.studentName === studentName);\n            console.log(\"getApplicationByStudent - Found by name:\", app);\n            // If found by name, update the studentId to match current user\n            if (app) {\n                console.log(\"getApplicationByStudent - Updating studentId from\", app.studentId, \"to\", studentId);\n                app.studentId = studentId;\n                // Save the updated application back to localStorage\n                localStorage.setItem(APPLICATIONS_KEY, JSON.stringify(applications));\n            }\n        }\n        console.log(\"getApplicationByStudent - Final result:\", app);\n        return app;\n    } catch (error) {\n        console.error(\"Error in getApplicationByStudent:\", error);\n        return undefined;\n    }\n};\nconst addApplication = (application)=>{\n    if (!isBrowser) throw new Error(\"Cannot add application on server side\");\n    const applications = getApplications();\n    const newApplication = {\n        ...application,\n        id: \"app_\".concat(Date.now()),\n        status: _types__WEBPACK_IMPORTED_MODULE_0__.ApplicationStatus.SUBMITTED,\n        submissionDate: new Date().toISOString()\n    };\n    applications.push(newApplication);\n    localStorage.setItem(APPLICATIONS_KEY, JSON.stringify(applications));\n    return newApplication;\n};\nconst updateApplicationStatus = (applicationId, status)=>{\n    if (!isBrowser) return undefined;\n    const applications = getApplications();\n    const appIndex = applications.findIndex((app)=>app.id === applicationId);\n    if (appIndex !== -1) {\n        applications[appIndex].status = status;\n        localStorage.setItem(APPLICATIONS_KEY, JSON.stringify(applications));\n        return applications[appIndex];\n    }\n    return undefined;\n};\nconst addEvaluationNoteToApplication = (applicationId, note)=>{\n    if (!isBrowser) return undefined;\n    const applications = getApplications();\n    const appIndex = applications.findIndex((app)=>app.id === applicationId);\n    if (appIndex !== -1) {\n        var _applications_appIndex_notes;\n        // FIX: Explicitly type `newNote` to ensure it matches the EvaluationNote interface.\n        const newNote = {\n            ...note,\n            id: \"note_\".concat(Date.now()),\n            timestamp: new Date().toISOString()\n        };\n        if (!applications[appIndex].notes) {\n            applications[appIndex].notes = [];\n        }\n        (_applications_appIndex_notes = applications[appIndex].notes) === null || _applications_appIndex_notes === void 0 ? void 0 : _applications_appIndex_notes.push(newNote);\n        localStorage.setItem(APPLICATIONS_KEY, JSON.stringify(applications));\n        return applications[appIndex];\n    }\n    return undefined;\n};\nconst deleteApplication = (applicationId)=>{\n    if (!isBrowser) return false;\n    const applications = getApplications();\n    const filteredApplications = applications.filter((app)=>app.id !== applicationId);\n    if (filteredApplications.length < applications.length) {\n        localStorage.setItem(APPLICATIONS_KEY, JSON.stringify(filteredApplications));\n        return true;\n    }\n    return false;\n};\nconst clearAllData = ()=>{\n    if (!isBrowser) return;\n    localStorage.removeItem(USERS_KEY);\n    localStorage.removeItem(APPLICATIONS_KEY);\n    // Re-seed the basic users\n    seedAdmin();\n    seedStudent();\n};\n// Migration function to fix existing applications with mismatched student IDs\nconst migrateApplicationStudentIds = ()=>{\n    if (!isBrowser) return;\n    try {\n        const applications = getApplications();\n        const users = getUsers();\n        let updated = false;\n        applications.forEach((app)=>{\n            // Check if the studentId in the application matches any existing user\n            const userExists = users.find((user)=>user.id === app.studentId);\n            if (!userExists) {\n                // Try to find user by name\n                const userByName = users.find((user)=>user.fullName === app.studentName);\n                if (userByName) {\n                    app.studentId = userByName.id;\n                    updated = true;\n                }\n            }\n        });\n        if (updated) {\n            localStorage.setItem(APPLICATIONS_KEY, JSON.stringify(applications));\n        }\n    } catch (error) {\n        console.error(\"Error in migration:\", error);\n    }\n};\n// Seeding functions (defined after main functions to avoid circular dependency)\nconst seedAdmin = ()=>{\n    if (!isBrowser) return;\n    const users = getUsers();\n    if (!users.some((u)=>u.role === _types__WEBPACK_IMPORTED_MODULE_0__.UserRole.ADMIN)) {\n        const admin = {\n            id: \"admin_01\",\n            email: \"admin@test.com\",\n            password: \"admin123\",\n            role: _types__WEBPACK_IMPORTED_MODULE_0__.UserRole.ADMIN,\n            fullName: \"HP Admin\"\n        };\n        users.push(admin);\n        localStorage.setItem(USERS_KEY, JSON.stringify(users));\n    }\n};\nconst seedStudent = ()=>{\n    if (!isBrowser) return;\n    const users = getUsers();\n    if (!users.some((u)=>u.email === \"student@test.com\")) {\n        const student = {\n            id: \"student_01\",\n            email: \"student@test.com\",\n            password: \"student123\",\n            role: _types__WEBPACK_IMPORTED_MODULE_0__.UserRole.STUDENT,\n            fullName: \"Test Student\",\n            college: \"Test University\"\n        };\n        users.push(student);\n        localStorage.setItem(USERS_KEY, JSON.stringify(users));\n    }\n};\n// Initialize with admin and student (only in browser)\nif (isBrowser) {\n    try {\n        if (!localStorage.getItem(USERS_KEY)) {\n            localStorage.setItem(USERS_KEY, JSON.stringify([]));\n            seedAdmin();\n            seedStudent();\n        } else {\n            // Ensure both users exist even if localStorage already has data\n            seedAdmin();\n            seedStudent();\n        // Run migration to fix any existing application student ID mismatches\n        // Temporarily disabled to fix loading issue\n        // try {\n        //     migrateApplicationStudentIds();\n        // } catch (error) {\n        //     console.error('Migration failed:', error);\n        // }\n        }\n    } catch (error) {\n        console.error(\"Storage service initialization failed:\", error);\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NlcnZpY2VzL3N0b3JhZ2VTZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ2dHO0FBRWhHLE1BQU1FLFlBQVk7QUFDbEIsTUFBTUMsbUJBQW1CO0FBRXpCLGdDQUFnQztBQUNoQyxNQUFNQyxZQUFZLGFBQWtCO0FBRXBDLGlCQUFpQjtBQUNWLE1BQU1DLFdBQVc7SUFDcEIsSUFBSSxDQUFDRCxXQUFXLE9BQU8sRUFBRTtJQUN6QixNQUFNRSxRQUFRQyxhQUFhQyxPQUFPLENBQUNOO0lBQ25DLE9BQU9JLFFBQVFHLEtBQUtDLEtBQUssQ0FBQ0osU0FBUyxFQUFFO0FBQ3pDLEVBQUU7QUFFSyxNQUFNSyxpQkFBaUIsQ0FBQ0M7SUFDM0IsT0FBT1AsV0FBV1EsSUFBSSxDQUFDQyxDQUFBQSxPQUFRQSxLQUFLRixLQUFLLEtBQUtBO0FBQ2xELEVBQUU7QUFFSyxNQUFNRyxjQUFjLENBQUNDO0lBQ3hCLE9BQU9YLFdBQVdRLElBQUksQ0FBQ0MsQ0FBQUEsT0FBUUEsS0FBS0UsRUFBRSxLQUFLQTtBQUMvQyxFQUFFO0FBRUssTUFBTUMsVUFBVSxDQUFDSDtJQUNwQixJQUFJLENBQUNWLFdBQVcsTUFBTSxJQUFJYyxNQUFNO0lBQ2hDLE1BQU1aLFFBQVFEO0lBQ2QsTUFBTWMsVUFBZ0I7UUFBRSxHQUFHTCxJQUFJO1FBQUVFLElBQUksUUFBbUIsT0FBWEksS0FBS0MsR0FBRztJQUFLO0lBQzFEZixNQUFNZ0IsSUFBSSxDQUFDSDtJQUNYWixhQUFhZ0IsT0FBTyxDQUFDckIsV0FBV08sS0FBS2UsU0FBUyxDQUFDbEI7SUFDL0MsT0FBT2E7QUFDWCxFQUFFO0FBR0Ysd0JBQXdCO0FBQ2pCLE1BQU1NLGtCQUFrQjtJQUMzQixJQUFJLENBQUNyQixXQUFXLE9BQU8sRUFBRTtJQUN6QixNQUFNc0IsZUFBZW5CLGFBQWFDLE9BQU8sQ0FBQ0w7SUFDMUMsT0FBT3VCLGVBQWVqQixLQUFLQyxLQUFLLENBQUNnQixn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Q1ZILE1BQU1wRSw0Q0FBUUEsQ0FBQ3lFLE9BQU87WUFDdEJSLFVBQVU7WUFDVlMsU0FBUztRQUNiO1FBQ0FwRSxNQUFNZ0IsSUFBSSxDQUFDa0Q7UUFDWGpFLGFBQWFnQixPQUFPLENBQUNyQixXQUFXTyxLQUFLZSxTQUFTLENBQUNsQjtJQUNuRDtBQUNKO0FBRUEsc0RBQXNEO0FBQ3RELElBQUlGLFdBQVc7SUFDWCxJQUFJO1FBQ0EsSUFBSSxDQUFDRyxhQUFhQyxPQUFPLENBQUNOLFlBQVk7WUFDbENLLGFBQWFnQixPQUFPLENBQUNyQixXQUFXTyxLQUFLZSxTQUFTLENBQUMsRUFBRTtZQUNqRGtDO1lBQ0FDO1FBQ0osT0FBTztZQUNILGdFQUFnRTtZQUNoRUQ7WUFDQUM7UUFDQSxzRUFBc0U7UUFDdEUsNENBQTRDO1FBQzVDLFFBQVE7UUFDUixzQ0FBc0M7UUFDdEMsb0JBQW9CO1FBQ3BCLGlEQUFpRDtRQUNqRCxJQUFJO1FBQ1I7SUFDSixFQUFFLE9BQU94QixPQUFPO1FBQ1pGLFFBQVFFLEtBQUssQ0FBQywwQ0FBMENBO0lBQzVEO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc2VydmljZXMvc3RvcmFnZVNlcnZpY2UudHM/ZjQyMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCB7IFVzZXIsIFVzZXJSb2xlLCBTdHVkZW50QXBwbGljYXRpb24sIEFwcGxpY2F0aW9uU3RhdHVzLCBFdmFsdWF0aW9uTm90ZSB9IGZyb20gJ0AvdHlwZXMnO1xuXG5jb25zdCBVU0VSU19LRVkgPSAnZmZmX3VzZXJzJztcbmNvbnN0IEFQUExJQ0FUSU9OU19LRVkgPSAnZmZmX2FwcGxpY2F0aW9ucyc7XG5cbi8vIENoZWNrIGlmIHdlJ3JlIGluIHRoZSBicm93c2VyXG5jb25zdCBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcblxuLy8gVXNlciBGdW5jdGlvbnNcbmV4cG9ydCBjb25zdCBnZXRVc2VycyA9ICgpOiBVc2VyW10gPT4ge1xuICAgIGlmICghaXNCcm93c2VyKSByZXR1cm4gW107XG4gICAgY29uc3QgdXNlcnMgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShVU0VSU19LRVkpO1xuICAgIHJldHVybiB1c2VycyA/IEpTT04ucGFyc2UodXNlcnMpIDogW107XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0VXNlckJ5RW1haWwgPSAoZW1haWw6IHN0cmluZyk6IFVzZXIgfCB1bmRlZmluZWQgPT4ge1xuICAgIHJldHVybiBnZXRVc2VycygpLmZpbmQodXNlciA9PiB1c2VyLmVtYWlsID09PSBlbWFpbCk7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0VXNlckJ5SWQgPSAoaWQ6IHN0cmluZyk6IFVzZXIgfCB1bmRlZmluZWQgPT4ge1xuICAgIHJldHVybiBnZXRVc2VycygpLmZpbmQodXNlciA9PiB1c2VyLmlkID09PSBpZCk7XG59O1xuXG5leHBvcnQgY29uc3QgYWRkVXNlciA9ICh1c2VyOiBPbWl0PFVzZXIsICdpZCc+KTogVXNlciA9PiB7XG4gICAgaWYgKCFpc0Jyb3dzZXIpIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFkZCB1c2VyIG9uIHNlcnZlciBzaWRlJyk7XG4gICAgY29uc3QgdXNlcnMgPSBnZXRVc2VycygpO1xuICAgIGNvbnN0IG5ld1VzZXI6IFVzZXIgPSB7IC4uLnVzZXIsIGlkOiBgdXNlcl8ke0RhdGUubm93KCl9YCB9O1xuICAgIHVzZXJzLnB1c2gobmV3VXNlcik7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oVVNFUlNfS0VZLCBKU09OLnN0cmluZ2lmeSh1c2VycykpO1xuICAgIHJldHVybiBuZXdVc2VyO1xufTtcblxuXG4vLyBBcHBsaWNhdGlvbiBGdW5jdGlvbnNcbmV4cG9ydCBjb25zdCBnZXRBcHBsaWNhdGlvbnMgPSAoKTogU3R1ZGVudEFwcGxpY2F0aW9uW10gPT4ge1xuICAgIGlmICghaXNCcm93c2VyKSByZXR1cm4gW107XG4gICAgY29uc3QgYXBwbGljYXRpb25zID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oQVBQTElDQVRJT05TX0tFWSk7XG4gICAgcmV0dXJuIGFwcGxpY2F0aW9ucyA/IEpTT04ucGFyc2UoYXBwbGljYXRpb25zKSA6IFtdO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldEFwcGxpY2F0aW9uQnlTdHVkZW50SWQgPSAoc3R1ZGVudElkOiBzdHJpbmcpOiBTdHVkZW50QXBwbGljYXRpb24gfCB1bmRlZmluZWQgPT4ge1xuICAgIHJldHVybiBnZXRBcHBsaWNhdGlvbnMoKS5maW5kKGFwcCA9PiBhcHAuc3R1ZGVudElkID09PSBzdHVkZW50SWQpO1xufTtcblxuLy8gRW5oYW5jZWQgZnVuY3Rpb24gdG8gZmluZCBhcHBsaWNhdGlvbiBieSBzdHVkZW50IElEIG9yIG5hbWUgKGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5KVxuZXhwb3J0IGNvbnN0IGdldEFwcGxpY2F0aW9uQnlTdHVkZW50ID0gKHN0dWRlbnRJZDogc3RyaW5nLCBzdHVkZW50TmFtZTogc3RyaW5nKTogU3R1ZGVudEFwcGxpY2F0aW9uIHwgdW5kZWZpbmVkID0+IHtcbiAgICBpZiAoIWlzQnJvd3NlcikgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBhcHBsaWNhdGlvbnMgPSBnZXRBcHBsaWNhdGlvbnMoKTtcbiAgICAgICAgY29uc29sZS5sb2coJ2dldEFwcGxpY2F0aW9uQnlTdHVkZW50IC0gQWxsIGFwcGxpY2F0aW9uczonLCBhcHBsaWNhdGlvbnMpO1xuICAgICAgICBjb25zb2xlLmxvZygnZ2V0QXBwbGljYXRpb25CeVN0dWRlbnQgLSBMb29raW5nIGZvciBzdHVkZW50SWQ6Jywgc3R1ZGVudElkLCAnc3R1ZGVudE5hbWU6Jywgc3R1ZGVudE5hbWUpO1xuICAgICAgICBcbiAgICAgICAgLy8gRmlyc3QgdHJ5IHRvIGZpbmQgYnkgZXhhY3Qgc3R1ZGVudCBJRFxuICAgICAgICBsZXQgYXBwID0gYXBwbGljYXRpb25zLmZpbmQoYXBwID0+IGFwcC5zdHVkZW50SWQgPT09IHN0dWRlbnRJZCk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdnZXRBcHBsaWNhdGlvbkJ5U3R1ZGVudCAtIEZvdW5kIGJ5IElEOicsIGFwcCk7XG4gICAgICAgIFxuICAgICAgICAvLyBJZiBub3QgZm91bmQsIHRyeSB0byBmaW5kIGJ5IHN0dWRlbnQgbmFtZSAoZm9yIGV4aXN0aW5nIGFwcGxpY2F0aW9ucyB3aXRoIGRpZmZlcmVudCBJRHMpXG4gICAgICAgIGlmICghYXBwKSB7XG4gICAgICAgICAgICBhcHAgPSBhcHBsaWNhdGlvbnMuZmluZChhcHAgPT4gYXBwLnN0dWRlbnROYW1lID09PSBzdHVkZW50TmFtZSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnZ2V0QXBwbGljYXRpb25CeVN0dWRlbnQgLSBGb3VuZCBieSBuYW1lOicsIGFwcCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIElmIGZvdW5kIGJ5IG5hbWUsIHVwZGF0ZSB0aGUgc3R1ZGVudElkIHRvIG1hdGNoIGN1cnJlbnQgdXNlclxuICAgICAgICAgICAgaWYgKGFwcCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdnZXRBcHBsaWNhdGlvbkJ5U3R1ZGVudCAtIFVwZGF0aW5nIHN0dWRlbnRJZCBmcm9tJywgYXBwLnN0dWRlbnRJZCwgJ3RvJywgc3R1ZGVudElkKTtcbiAgICAgICAgICAgICAgICBhcHAuc3R1ZGVudElkID0gc3R1ZGVudElkO1xuICAgICAgICAgICAgICAgIC8vIFNhdmUgdGhlIHVwZGF0ZWQgYXBwbGljYXRpb24gYmFjayB0byBsb2NhbFN0b3JhZ2VcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShBUFBMSUNBVElPTlNfS0VZLCBKU09OLnN0cmluZ2lmeShhcHBsaWNhdGlvbnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coJ2dldEFwcGxpY2F0aW9uQnlTdHVkZW50IC0gRmluYWwgcmVzdWx0OicsIGFwcCk7XG4gICAgICAgIHJldHVybiBhcHA7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZ2V0QXBwbGljYXRpb25CeVN0dWRlbnQ6JywgZXJyb3IpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn07XG5cbmV4cG9ydCBjb25zdCBhZGRBcHBsaWNhdGlvbiA9IChhcHBsaWNhdGlvbjogT21pdDxTdHVkZW50QXBwbGljYXRpb24sICdpZCcgfCAnc3RhdHVzJyB8ICdzdWJtaXNzaW9uRGF0ZSc+KTogU3R1ZGVudEFwcGxpY2F0aW9uID0+IHtcbiAgICBpZiAoIWlzQnJvd3NlcikgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYWRkIGFwcGxpY2F0aW9uIG9uIHNlcnZlciBzaWRlJyk7XG4gICAgY29uc3QgYXBwbGljYXRpb25zID0gZ2V0QXBwbGljYXRpb25zKCk7XG4gICAgY29uc3QgbmV3QXBwbGljYXRpb246IFN0dWRlbnRBcHBsaWNhdGlvbiA9IHtcbiAgICAgICAgLi4uYXBwbGljYXRpb24sXG4gICAgICAgIGlkOiBgYXBwXyR7RGF0ZS5ub3coKX1gLFxuICAgICAgICBzdGF0dXM6IEFwcGxpY2F0aW9uU3RhdHVzLlNVQk1JVFRFRCxcbiAgICAgICAgc3VibWlzc2lvbkRhdGU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgIH07XG4gICAgYXBwbGljYXRpb25zLnB1c2gobmV3QXBwbGljYXRpb24pO1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKEFQUExJQ0FUSU9OU19LRVksIEpTT04uc3RyaW5naWZ5KGFwcGxpY2F0aW9ucykpO1xuICAgIHJldHVybiBuZXdBcHBsaWNhdGlvbjtcbn07XG5cbmV4cG9ydCBjb25zdCB1cGRhdGVBcHBsaWNhdGlvblN0YXR1cyA9IChhcHBsaWNhdGlvbklkOiBzdHJpbmcsIHN0YXR1czogQXBwbGljYXRpb25TdGF0dXMpOiBTdHVkZW50QXBwbGljYXRpb24gfCB1bmRlZmluZWQgPT4ge1xuICAgIGlmICghaXNCcm93c2VyKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGFwcGxpY2F0aW9ucyA9IGdldEFwcGxpY2F0aW9ucygpO1xuICAgIGNvbnN0IGFwcEluZGV4ID0gYXBwbGljYXRpb25zLmZpbmRJbmRleChhcHAgPT4gYXBwLmlkID09PSBhcHBsaWNhdGlvbklkKTtcbiAgICBpZiAoYXBwSW5kZXggIT09IC0xKSB7XG4gICAgICAgIGFwcGxpY2F0aW9uc1thcHBJbmRleF0uc3RhdHVzID0gc3RhdHVzO1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShBUFBMSUNBVElPTlNfS0VZLCBKU09OLnN0cmluZ2lmeShhcHBsaWNhdGlvbnMpKTtcbiAgICAgICAgcmV0dXJuIGFwcGxpY2F0aW9uc1thcHBJbmRleF07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG5leHBvcnQgY29uc3QgYWRkRXZhbHVhdGlvbk5vdGVUb0FwcGxpY2F0aW9uID0gKGFwcGxpY2F0aW9uSWQ6IHN0cmluZywgbm90ZTogT21pdDxFdmFsdWF0aW9uTm90ZSwgJ2lkJyB8ICd0aW1lc3RhbXAnPik6IFN0dWRlbnRBcHBsaWNhdGlvbiB8IHVuZGVmaW5lZCA9PiB7XG4gICAgaWYgKCFpc0Jyb3dzZXIpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3QgYXBwbGljYXRpb25zID0gZ2V0QXBwbGljYXRpb25zKCk7XG4gICAgY29uc3QgYXBwSW5kZXggPSBhcHBsaWNhdGlvbnMuZmluZEluZGV4KGFwcCA9PiBhcHAuaWQgPT09IGFwcGxpY2F0aW9uSWQpO1xuICAgIGlmIChhcHBJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgLy8gRklYOiBFeHBsaWNpdGx5IHR5cGUgYG5ld05vdGVgIHRvIGVuc3VyZSBpdCBtYXRjaGVzIHRoZSBFdmFsdWF0aW9uTm90ZSBpbnRlcmZhY2UuXG4gICAgICAgIGNvbnN0IG5ld05vdGU6IEV2YWx1YXRpb25Ob3RlID0ge1xuICAgICAgICAgICAgLi4ubm90ZSxcbiAgICAgICAgICAgIGlkOiBgbm90ZV8ke0RhdGUubm93KCl9YCxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgIH07XG4gICAgICAgIGlmICghYXBwbGljYXRpb25zW2FwcEluZGV4XS5ub3Rlcykge1xuICAgICAgICAgICAgYXBwbGljYXRpb25zW2FwcEluZGV4XS5ub3RlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGFwcGxpY2F0aW9uc1thcHBJbmRleF0ubm90ZXM/LnB1c2gobmV3Tm90ZSk7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKEFQUExJQ0FUSU9OU19LRVksIEpTT04uc3RyaW5naWZ5KGFwcGxpY2F0aW9ucykpO1xuICAgICAgICByZXR1cm4gYXBwbGljYXRpb25zW2FwcEluZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbmV4cG9ydCBjb25zdCBkZWxldGVBcHBsaWNhdGlvbiA9IChhcHBsaWNhdGlvbklkOiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgICBpZiAoIWlzQnJvd3NlcikgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGFwcGxpY2F0aW9ucyA9IGdldEFwcGxpY2F0aW9ucygpO1xuICAgIGNvbnN0IGZpbHRlcmVkQXBwbGljYXRpb25zID0gYXBwbGljYXRpb25zLmZpbHRlcihhcHAgPT4gYXBwLmlkICE9PSBhcHBsaWNhdGlvbklkKTtcbiAgICBpZiAoZmlsdGVyZWRBcHBsaWNhdGlvbnMubGVuZ3RoIDwgYXBwbGljYXRpb25zLmxlbmd0aCkge1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShBUFBMSUNBVElPTlNfS0VZLCBKU09OLnN0cmluZ2lmeShmaWx0ZXJlZEFwcGxpY2F0aW9ucykpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuZXhwb3J0IGNvbnN0IGNsZWFyQWxsRGF0YSA9ICgpOiB2b2lkID0+IHtcbiAgICBpZiAoIWlzQnJvd3NlcikgcmV0dXJuO1xuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKFVTRVJTX0tFWSk7XG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oQVBQTElDQVRJT05TX0tFWSk7XG4gICAgLy8gUmUtc2VlZCB0aGUgYmFzaWMgdXNlcnNcbiAgICBzZWVkQWRtaW4oKTtcbiAgICBzZWVkU3R1ZGVudCgpO1xufTtcblxuLy8gTWlncmF0aW9uIGZ1bmN0aW9uIHRvIGZpeCBleGlzdGluZyBhcHBsaWNhdGlvbnMgd2l0aCBtaXNtYXRjaGVkIHN0dWRlbnQgSURzXG5leHBvcnQgY29uc3QgbWlncmF0ZUFwcGxpY2F0aW9uU3R1ZGVudElkcyA9ICgpOiB2b2lkID0+IHtcbiAgICBpZiAoIWlzQnJvd3NlcikgcmV0dXJuO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGFwcGxpY2F0aW9ucyA9IGdldEFwcGxpY2F0aW9ucygpO1xuICAgICAgICBjb25zdCB1c2VycyA9IGdldFVzZXJzKCk7XG4gICAgICAgIGxldCB1cGRhdGVkID0gZmFsc2U7XG4gICAgICAgIFxuICAgICAgICBhcHBsaWNhdGlvbnMuZm9yRWFjaChhcHAgPT4ge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHN0dWRlbnRJZCBpbiB0aGUgYXBwbGljYXRpb24gbWF0Y2hlcyBhbnkgZXhpc3RpbmcgdXNlclxuICAgICAgICAgICAgY29uc3QgdXNlckV4aXN0cyA9IHVzZXJzLmZpbmQodXNlciA9PiB1c2VyLmlkID09PSBhcHAuc3R1ZGVudElkKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCF1c2VyRXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgLy8gVHJ5IHRvIGZpbmQgdXNlciBieSBuYW1lXG4gICAgICAgICAgICAgICAgY29uc3QgdXNlckJ5TmFtZSA9IHVzZXJzLmZpbmQodXNlciA9PiB1c2VyLmZ1bGxOYW1lID09PSBhcHAuc3R1ZGVudE5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICh1c2VyQnlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcC5zdHVkZW50SWQgPSB1c2VyQnlOYW1lLmlkO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgaWYgKHVwZGF0ZWQpIHtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKEFQUExJQ0FUSU9OU19LRVksIEpTT04uc3RyaW5naWZ5KGFwcGxpY2F0aW9ucykpO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gbWlncmF0aW9uOicsIGVycm9yKTtcbiAgICB9XG59O1xuXG4vLyBTZWVkaW5nIGZ1bmN0aW9ucyAoZGVmaW5lZCBhZnRlciBtYWluIGZ1bmN0aW9ucyB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmN5KVxuY29uc3Qgc2VlZEFkbWluID0gKCkgPT4ge1xuICAgIGlmICghaXNCcm93c2VyKSByZXR1cm47XG4gICAgXG4gICAgY29uc3QgdXNlcnMgPSBnZXRVc2VycygpO1xuICAgIGlmICghdXNlcnMuc29tZSh1ID0+IHUucm9sZSA9PT0gVXNlclJvbGUuQURNSU4pKSB7XG4gICAgICAgIGNvbnN0IGFkbWluOiBVc2VyID0ge1xuICAgICAgICAgICAgaWQ6ICdhZG1pbl8wMScsXG4gICAgICAgICAgICBlbWFpbDogJ2FkbWluQHRlc3QuY29tJyxcbiAgICAgICAgICAgIHBhc3N3b3JkOiAnYWRtaW4xMjMnLFxuICAgICAgICAgICAgcm9sZTogVXNlclJvbGUuQURNSU4sXG4gICAgICAgICAgICBmdWxsTmFtZTogJ0hQIEFkbWluJ1xuICAgICAgICB9O1xuICAgICAgICB1c2Vycy5wdXNoKGFkbWluKTtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oVVNFUlNfS0VZLCBKU09OLnN0cmluZ2lmeSh1c2VycykpO1xuICAgIH1cbn07XG5cbmNvbnN0IHNlZWRTdHVkZW50ID0gKCkgPT4ge1xuICAgIGlmICghaXNCcm93c2VyKSByZXR1cm47XG4gICAgXG4gICAgY29uc3QgdXNlcnMgPSBnZXRVc2VycygpO1xuICAgIGlmICghdXNlcnMuc29tZSh1ID0+IHUuZW1haWwgPT09ICdzdHVkZW50QHRlc3QuY29tJykpIHtcbiAgICAgICAgY29uc3Qgc3R1ZGVudDogVXNlciA9IHtcbiAgICAgICAgICAgIGlkOiAnc3R1ZGVudF8wMScsXG4gICAgICAgICAgICBlbWFpbDogJ3N0dWRlbnRAdGVzdC5jb20nLFxuICAgICAgICAgICAgcGFzc3dvcmQ6ICdzdHVkZW50MTIzJyxcbiAgICAgICAgICAgIHJvbGU6IFVzZXJSb2xlLlNUVURFTlQsXG4gICAgICAgICAgICBmdWxsTmFtZTogJ1Rlc3QgU3R1ZGVudCcsXG4gICAgICAgICAgICBjb2xsZWdlOiAnVGVzdCBVbml2ZXJzaXR5J1xuICAgICAgICB9O1xuICAgICAgICB1c2Vycy5wdXNoKHN0dWRlbnQpO1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShVU0VSU19LRVksIEpTT04uc3RyaW5naWZ5KHVzZXJzKSk7XG4gICAgfVxufTtcblxuLy8gSW5pdGlhbGl6ZSB3aXRoIGFkbWluIGFuZCBzdHVkZW50IChvbmx5IGluIGJyb3dzZXIpXG5pZiAoaXNCcm93c2VyKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKCFsb2NhbFN0b3JhZ2UuZ2V0SXRlbShVU0VSU19LRVkpKSB7XG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShVU0VSU19LRVksIEpTT04uc3RyaW5naWZ5KFtdKSk7XG4gICAgICAgICAgICBzZWVkQWRtaW4oKTtcbiAgICAgICAgICAgIHNlZWRTdHVkZW50KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBFbnN1cmUgYm90aCB1c2VycyBleGlzdCBldmVuIGlmIGxvY2FsU3RvcmFnZSBhbHJlYWR5IGhhcyBkYXRhXG4gICAgICAgICAgICBzZWVkQWRtaW4oKTtcbiAgICAgICAgICAgIHNlZWRTdHVkZW50KCk7XG4gICAgICAgICAgICAvLyBSdW4gbWlncmF0aW9uIHRvIGZpeCBhbnkgZXhpc3RpbmcgYXBwbGljYXRpb24gc3R1ZGVudCBJRCBtaXNtYXRjaGVzXG4gICAgICAgICAgICAvLyBUZW1wb3JhcmlseSBkaXNhYmxlZCB0byBmaXggbG9hZGluZyBpc3N1ZVxuICAgICAgICAgICAgLy8gdHJ5IHtcbiAgICAgICAgICAgIC8vICAgICBtaWdyYXRlQXBwbGljYXRpb25TdHVkZW50SWRzKCk7XG4gICAgICAgICAgICAvLyB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gICAgIGNvbnNvbGUuZXJyb3IoJ01pZ3JhdGlvbiBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignU3RvcmFnZSBzZXJ2aWNlIGluaXRpYWxpemF0aW9uIGZhaWxlZDonLCBlcnJvcik7XG4gICAgfVxufSJdLCJuYW1lcyI6WyJVc2VyUm9sZSIsIkFwcGxpY2F0aW9uU3RhdHVzIiwiVVNFUlNfS0VZIiwiQVBQTElDQVRJT05TX0tFWSIsImlzQnJvd3NlciIsImdldFVzZXJzIiwidXNlcnMiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiSlNPTiIsInBhcnNlIiwiZ2V0VXNlckJ5RW1haWwiLCJlbWFpbCIsImZpbmQiLCJ1c2VyIiwiZ2V0VXNlckJ5SWQiLCJpZCIsImFkZFVzZXIiLCJFcnJvciIsIm5ld1VzZXIiLCJEYXRlIiwibm93IiwicHVzaCIsInNldEl0ZW0iLCJzdHJpbmdpZnkiLCJnZXRBcHBsaWNhdGlvbnMiLCJhcHBsaWNhdGlvbnMiLCJnZXRBcHBsaWNhdGlvbkJ5U3R1ZGVudElkIiwic3R1ZGVudElkIiwiYXBwIiwiZ2V0QXBwbGljYXRpb25CeVN0dWRlbnQiLCJzdHVkZW50TmFtZSIsInVuZGVmaW5lZCIsImNvbnNvbGUiLCJsb2ciLCJlcnJvciIsImFkZEFwcGxpY2F0aW9uIiwiYXBwbGljYXRpb24iLCJuZXdBcHBsaWNhdGlvbiIsInN0YXR1cyIsIlNVQk1JVFRFRCIsInN1Ym1pc3Npb25EYXRlIiwidG9JU09TdHJpbmciLCJ1cGRhdGVBcHBsaWNhdGlvblN0YXR1cyIsImFwcGxpY2F0aW9uSWQiLCJhcHBJbmRleCIsImZpbmRJbmRleCIsImFkZEV2YWx1YXRpb25Ob3RlVG9BcHBsaWNhdGlvbiIsIm5vdGUiLCJuZXdOb3RlIiwidGltZXN0YW1wIiwibm90ZXMiLCJkZWxldGVBcHBsaWNhdGlvbiIsImZpbHRlcmVkQXBwbGljYXRpb25zIiwiZmlsdGVyIiwibGVuZ3RoIiwiY2xlYXJBbGxEYXRhIiwicmVtb3ZlSXRlbSIsInNlZWRBZG1pbiIsInNlZWRTdHVkZW50IiwibWlncmF0ZUFwcGxpY2F0aW9uU3R1ZGVudElkcyIsInVwZGF0ZWQiLCJmb3JFYWNoIiwidXNlckV4aXN0cyIsInVzZXJCeU5hbWUiLCJmdWxsTmFtZSIsInNvbWUiLCJ1Iiwicm9sZSIsIkFETUlOIiwiYWRtaW4iLCJwYXNzd29yZCIsInN0dWRlbnQiLCJTVFVERU5UIiwiY29sbGVnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./services/storageService.ts\n"));

/***/ })

});