"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./services/storageService.ts":
/*!************************************!*\
  !*** ./services/storageService.ts ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addApplication: function() { return /* binding */ addApplication; },\n/* harmony export */   addEvaluationNoteToApplication: function() { return /* binding */ addEvaluationNoteToApplication; },\n/* harmony export */   addUser: function() { return /* binding */ addUser; },\n/* harmony export */   clearAllData: function() { return /* binding */ clearAllData; },\n/* harmony export */   deleteApplication: function() { return /* binding */ deleteApplication; },\n/* harmony export */   getApplicationByStudent: function() { return /* binding */ getApplicationByStudent; },\n/* harmony export */   getApplicationByStudentId: function() { return /* binding */ getApplicationByStudentId; },\n/* harmony export */   getApplications: function() { return /* binding */ getApplications; },\n/* harmony export */   getUserByEmail: function() { return /* binding */ getUserByEmail; },\n/* harmony export */   getUserById: function() { return /* binding */ getUserById; },\n/* harmony export */   getUsers: function() { return /* binding */ getUsers; },\n/* harmony export */   migrateApplicationStudentIds: function() { return /* binding */ migrateApplicationStudentIds; },\n/* harmony export */   updateApplicationStatus: function() { return /* binding */ updateApplicationStatus; }\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/types */ \"(app-pages-browser)/./types.ts\");\n\nconst USERS_KEY = \"fff_users\";\nconst APPLICATIONS_KEY = \"fff_applications\";\n// Check if we're in the browser\nconst isBrowser = \"object\" !== \"undefined\";\n// User Functions\nconst getUsers = ()=>{\n    if (!isBrowser) return [];\n    const users = localStorage.getItem(USERS_KEY);\n    return users ? JSON.parse(users) : [];\n};\nconst getUserByEmail = (email)=>{\n    return getUsers().find((user)=>user.email === email);\n};\nconst getUserById = (id)=>{\n    return getUsers().find((user)=>user.id === id);\n};\nconst addUser = (user)=>{\n    if (!isBrowser) throw new Error(\"Cannot add user on server side\");\n    const users = getUsers();\n    const newUser = {\n        ...user,\n        id: \"user_\".concat(Date.now())\n    };\n    users.push(newUser);\n    localStorage.setItem(USERS_KEY, JSON.stringify(users));\n    return newUser;\n};\n// Application Functions\nconst getApplications = ()=>{\n    if (!isBrowser) return [];\n    const applications = localStorage.getItem(APPLICATIONS_KEY);\n    console.log(\"getApplications - Raw localStorage data:\", applications);\n    const parsed = applications ? JSON.parse(applications) : [];\n    console.log(\"getApplications - Parsed applications:\", parsed);\n    return parsed;\n};\nconst getApplicationByStudentId = (studentId)=>{\n    return getApplications().find((app)=>app.studentId === studentId);\n};\n// Enhanced function to find application by student ID or name (for backward compatibility)\nconst getApplicationByStudent = (studentId, studentName)=>{\n    if (!isBrowser) return undefined;\n    try {\n        const applications = getApplications();\n        console.log(\"getApplicationByStudent - All applications:\", applications);\n        console.log(\"getApplicationByStudent - Looking for studentId:\", studentId, \"studentName:\", studentName);\n        // First try to find by exact student ID\n        let app = applications.find((app)=>app.studentId === studentId);\n        console.log(\"getApplicationByStudent - Found by ID:\", app);\n        // If not found, try to find by student name (for existing applications with different IDs)\n        if (!app) {\n            app = applications.find((app)=>app.studentName === studentName);\n            console.log(\"getApplicationByStudent - Found by name:\", app);\n            // If found by name, update the studentId to match current user\n            if (app) {\n                console.log(\"getApplicationByStudent - Updating studentId from\", app.studentId, \"to\", studentId);\n                app.studentId = studentId;\n                // Save the updated application back to localStorage\n                localStorage.setItem(APPLICATIONS_KEY, JSON.stringify(applications));\n            }\n        }\n        console.log(\"getApplicationByStudent - Final result:\", app);\n        return app;\n    } catch (error) {\n        console.error(\"Error in getApplicationByStudent:\", error);\n        return undefined;\n    }\n};\nconst addApplication = (application)=>{\n    if (!isBrowser) throw new Error(\"Cannot add application on server side\");\n    const applications = getApplications();\n    const newApplication = {\n        ...application,\n        id: \"app_\".concat(Date.now()),\n        status: _types__WEBPACK_IMPORTED_MODULE_0__.ApplicationStatus.SUBMITTED,\n        submissionDate: new Date().toISOString()\n    };\n    applications.push(newApplication);\n    localStorage.setItem(APPLICATIONS_KEY, JSON.stringify(applications));\n    return newApplication;\n};\nconst updateApplicationStatus = (applicationId, status)=>{\n    if (!isBrowser) return undefined;\n    const applications = getApplications();\n    const appIndex = applications.findIndex((app)=>app.id === applicationId);\n    if (appIndex !== -1) {\n        applications[appIndex].status = status;\n        localStorage.setItem(APPLICATIONS_KEY, JSON.stringify(applications));\n        return applications[appIndex];\n    }\n    return undefined;\n};\nconst addEvaluationNoteToApplication = (applicationId, note)=>{\n    if (!isBrowser) return undefined;\n    const applications = getApplications();\n    const appIndex = applications.findIndex((app)=>app.id === applicationId);\n    if (appIndex !== -1) {\n        var _applications_appIndex_notes;\n        // FIX: Explicitly type `newNote` to ensure it matches the EvaluationNote interface.\n        const newNote = {\n            ...note,\n            id: \"note_\".concat(Date.now()),\n            timestamp: new Date().toISOString()\n        };\n        if (!applications[appIndex].notes) {\n            applications[appIndex].notes = [];\n        }\n        (_applications_appIndex_notes = applications[appIndex].notes) === null || _applications_appIndex_notes === void 0 ? void 0 : _applications_appIndex_notes.push(newNote);\n        localStorage.setItem(APPLICATIONS_KEY, JSON.stringify(applications));\n        return applications[appIndex];\n    }\n    return undefined;\n};\nconst deleteApplication = (applicationId)=>{\n    if (!isBrowser) return false;\n    const applications = getApplications();\n    const filteredApplications = applications.filter((app)=>app.id !== applicationId);\n    if (filteredApplications.length < applications.length) {\n        localStorage.setItem(APPLICATIONS_KEY, JSON.stringify(filteredApplications));\n        return true;\n    }\n    return false;\n};\nconst clearAllData = ()=>{\n    if (!isBrowser) return;\n    localStorage.removeItem(USERS_KEY);\n    localStorage.removeItem(APPLICATIONS_KEY);\n    // Re-seed the basic users\n    seedAdmin();\n    seedStudent();\n};\n// Migration function to fix existing applications with mismatched student IDs\nconst migrateApplicationStudentIds = ()=>{\n    if (!isBrowser) return;\n    try {\n        const applications = getApplications();\n        const users = getUsers();\n        let updated = false;\n        applications.forEach((app)=>{\n            // Check if the studentId in the application matches any existing user\n            const userExists = users.find((user)=>user.id === app.studentId);\n            if (!userExists) {\n                // Try to find user by name\n                const userByName = users.find((user)=>user.fullName === app.studentName);\n                if (userByName) {\n                    app.studentId = userByName.id;\n                    updated = true;\n                }\n            }\n        });\n        if (updated) {\n            localStorage.setItem(APPLICATIONS_KEY, JSON.stringify(applications));\n        }\n    } catch (error) {\n        console.error(\"Error in migration:\", error);\n    }\n};\n// Seeding functions (defined after main functions to avoid circular dependency)\nconst seedAdmin = ()=>{\n    if (!isBrowser) return;\n    const users = getUsers();\n    if (!users.some((u)=>u.role === _types__WEBPACK_IMPORTED_MODULE_0__.UserRole.ADMIN)) {\n        const admin = {\n            id: \"admin_01\",\n            email: \"admin@test.com\",\n            password: \"admin123\",\n            role: _types__WEBPACK_IMPORTED_MODULE_0__.UserRole.ADMIN,\n            fullName: \"HP Admin\"\n        };\n        users.push(admin);\n        localStorage.setItem(USERS_KEY, JSON.stringify(users));\n    }\n};\nconst seedStudent = ()=>{\n    if (!isBrowser) return;\n    const users = getUsers();\n    if (!users.some((u)=>u.email === \"student@test.com\")) {\n        const student = {\n            id: \"student_01\",\n            email: \"student@test.com\",\n            password: \"student123\",\n            role: _types__WEBPACK_IMPORTED_MODULE_0__.UserRole.STUDENT,\n            fullName: \"Test Student\",\n            college: \"Test University\"\n        };\n        users.push(student);\n        localStorage.setItem(USERS_KEY, JSON.stringify(users));\n    }\n};\n// Initialize with admin and student (only in browser)\nif (isBrowser) {\n    try {\n        if (!localStorage.getItem(USERS_KEY)) {\n            localStorage.setItem(USERS_KEY, JSON.stringify([]));\n            seedAdmin();\n            seedStudent();\n        } else {\n            // Ensure both users exist even if localStorage already has data\n            seedAdmin();\n            seedStudent();\n        // Run migration to fix any existing application student ID mismatches\n        // Temporarily disabled to fix loading issue\n        // try {\n        //     migrateApplicationStudentIds();\n        // } catch (error) {\n        //     console.error('Migration failed:', error);\n        // }\n        }\n    } catch (error) {\n        console.error(\"Storage service initialization failed:\", error);\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NlcnZpY2VzL3N0b3JhZ2VTZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ2dHO0FBRWhHLE1BQU1FLFlBQVk7QUFDbEIsTUFBTUMsbUJBQW1CO0FBRXpCLGdDQUFnQztBQUNoQyxNQUFNQyxZQUFZLGFBQWtCO0FBRXBDLGlCQUFpQjtBQUNWLE1BQU1DLFdBQVc7SUFDcEIsSUFBSSxDQUFDRCxXQUFXLE9BQU8sRUFBRTtJQUN6QixNQUFNRSxRQUFRQyxhQUFhQyxPQUFPLENBQUNOO0lBQ25DLE9BQU9JLFFBQVFHLEtBQUtDLEtBQUssQ0FBQ0osU0FBUyxFQUFFO0FBQ3pDLEVBQUU7QUFFSyxNQUFNSyxpQkFBaUIsQ0FBQ0M7SUFDM0IsT0FBT1AsV0FBV1EsSUFBSSxDQUFDQyxDQUFBQSxPQUFRQSxLQUFLRixLQUFLLEtBQUtBO0FBQ2xELEVBQUU7QUFFSyxNQUFNRyxjQUFjLENBQUNDO0lBQ3hCLE9BQU9YLFdBQVdRLElBQUksQ0FBQ0MsQ0FBQUEsT0FBUUEsS0FBS0UsRUFBRSxLQUFLQTtBQUMvQyxFQUFFO0FBRUssTUFBTUMsVUFBVSxDQUFDSDtJQUNwQixJQUFJLENBQUNWLFdBQVcsTUFBTSxJQUFJYyxNQUFNO0lBQ2hDLE1BQU1aLFFBQVFEO0lBQ2QsTUFBTWMsVUFBZ0I7UUFBRSxHQUFHTCxJQUFJO1FBQUVFLElBQUksUUFBbUIsT0FBWEksS0FBS0MsR0FBRztJQUFLO0lBQzFEZixNQUFNZ0IsSUFBSSxDQUFDSDtJQUNYWixhQUFhZ0IsT0FBTyxDQUFDckIsV0FBV08sS0FBS2UsU0FBUyxDQUFDbEI7SUFDL0MsT0FBT2E7QUFDWCxFQUFFO0FBR0Ysd0JBQXdCO0FBQ2pCLE1BQU1NLGtCQUFrQjtJQUMzQixJQUFJLENBQUNyQixXQUFXLE9BQU8sRUFBRTtJQUN6QixNQUFNc0IsZUFBZW5CLGFBQWFDLE9BQU8sQ0FBQ0w7SUFDMUN3QixRQUFRQyxHQUFHLENBQUMsNENBQTRDRjtJQUN4RCxN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RUFBRXhELEtBQUssS0FBSyxxQkFBcUI7UUFDbEQsTUFBTTZELFVBQWdCO1lBQ2xCekQsSUFBSTtZQUNKSixPQUFPO1lBQ1A0RCxVQUFVO1lBQ1ZILE1BQU1yRSw0Q0FBUUEsQ0FBQzBFLE9BQU87WUFDdEJSLFVBQVU7WUFDVlMsU0FBUztRQUNiO1FBQ0FyRSxNQUFNZ0IsSUFBSSxDQUFDbUQ7UUFDWGxFLGFBQWFnQixPQUFPLENBQUNyQixXQUFXTyxLQUFLZSxTQUFTLENBQUNsQjtJQUNuRDtBQUNKO0FBRUEsc0RBQXNEO0FBQ3RELElBQUlGLFdBQVc7SUFDWCxJQUFJO1FBQ0EsSUFBSSxDQUFDRyxhQUFhQyxPQUFPLENBQUNOLFlBQVk7WUFDbENLLGFBQWFnQixPQUFPLENBQUNyQixXQUFXTyxLQUFLZSxTQUFTLENBQUMsRUFBRTtZQUNqRG1DO1lBQ0FDO1FBQ0osT0FBTztZQUNILGdFQUFnRTtZQUNoRUQ7WUFDQUM7UUFDQSxzRUFBc0U7UUFDdEUsNENBQTRDO1FBQzVDLFFBQVE7UUFDUixzQ0FBc0M7UUFDdEMsb0JBQW9CO1FBQ3BCLGlEQUFpRDtRQUNqRCxJQUFJO1FBQ1I7SUFDSixFQUFFLE9BQU94QixPQUFPO1FBQ1pULFFBQVFTLEtBQUssQ0FBQywwQ0FBMENBO0lBQzVEO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc2VydmljZXMvc3RvcmFnZVNlcnZpY2UudHM/ZjQyMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCB7IFVzZXIsIFVzZXJSb2xlLCBTdHVkZW50QXBwbGljYXRpb24sIEFwcGxpY2F0aW9uU3RhdHVzLCBFdmFsdWF0aW9uTm90ZSB9IGZyb20gJ0AvdHlwZXMnO1xuXG5jb25zdCBVU0VSU19LRVkgPSAnZmZmX3VzZXJzJztcbmNvbnN0IEFQUExJQ0FUSU9OU19LRVkgPSAnZmZmX2FwcGxpY2F0aW9ucyc7XG5cbi8vIENoZWNrIGlmIHdlJ3JlIGluIHRoZSBicm93c2VyXG5jb25zdCBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcblxuLy8gVXNlciBGdW5jdGlvbnNcbmV4cG9ydCBjb25zdCBnZXRVc2VycyA9ICgpOiBVc2VyW10gPT4ge1xuICAgIGlmICghaXNCcm93c2VyKSByZXR1cm4gW107XG4gICAgY29uc3QgdXNlcnMgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShVU0VSU19LRVkpO1xuICAgIHJldHVybiB1c2VycyA/IEpTT04ucGFyc2UodXNlcnMpIDogW107XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0VXNlckJ5RW1haWwgPSAoZW1haWw6IHN0cmluZyk6IFVzZXIgfCB1bmRlZmluZWQgPT4ge1xuICAgIHJldHVybiBnZXRVc2VycygpLmZpbmQodXNlciA9PiB1c2VyLmVtYWlsID09PSBlbWFpbCk7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0VXNlckJ5SWQgPSAoaWQ6IHN0cmluZyk6IFVzZXIgfCB1bmRlZmluZWQgPT4ge1xuICAgIHJldHVybiBnZXRVc2VycygpLmZpbmQodXNlciA9PiB1c2VyLmlkID09PSBpZCk7XG59O1xuXG5leHBvcnQgY29uc3QgYWRkVXNlciA9ICh1c2VyOiBPbWl0PFVzZXIsICdpZCc+KTogVXNlciA9PiB7XG4gICAgaWYgKCFpc0Jyb3dzZXIpIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFkZCB1c2VyIG9uIHNlcnZlciBzaWRlJyk7XG4gICAgY29uc3QgdXNlcnMgPSBnZXRVc2VycygpO1xuICAgIGNvbnN0IG5ld1VzZXI6IFVzZXIgPSB7IC4uLnVzZXIsIGlkOiBgdXNlcl8ke0RhdGUubm93KCl9YCB9O1xuICAgIHVzZXJzLnB1c2gobmV3VXNlcik7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oVVNFUlNfS0VZLCBKU09OLnN0cmluZ2lmeSh1c2VycykpO1xuICAgIHJldHVybiBuZXdVc2VyO1xufTtcblxuXG4vLyBBcHBsaWNhdGlvbiBGdW5jdGlvbnNcbmV4cG9ydCBjb25zdCBnZXRBcHBsaWNhdGlvbnMgPSAoKTogU3R1ZGVudEFwcGxpY2F0aW9uW10gPT4ge1xuICAgIGlmICghaXNCcm93c2VyKSByZXR1cm4gW107XG4gICAgY29uc3QgYXBwbGljYXRpb25zID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oQVBQTElDQVRJT05TX0tFWSk7XG4gICAgY29uc29sZS5sb2coJ2dldEFwcGxpY2F0aW9ucyAtIFJhdyBsb2NhbFN0b3JhZ2UgZGF0YTonLCBhcHBsaWNhdGlvbnMpO1xuICAgIGNvbnN0IHBhcnNlZCA9IGFwcGxpY2F0aW9ucyA/IEpTT04ucGFyc2UoYXBwbGljYXRpb25zKSA6IFtdO1xuICAgIGNvbnNvbGUubG9nKCdnZXRBcHBsaWNhdGlvbnMgLSBQYXJzZWQgYXBwbGljYXRpb25zOicsIHBhcnNlZCk7XG4gICAgcmV0dXJuIHBhcnNlZDtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRBcHBsaWNhdGlvbkJ5U3R1ZGVudElkID0gKHN0dWRlbnRJZDogc3RyaW5nKTogU3R1ZGVudEFwcGxpY2F0aW9uIHwgdW5kZWZpbmVkID0+IHtcbiAgICByZXR1cm4gZ2V0QXBwbGljYXRpb25zKCkuZmluZChhcHAgPT4gYXBwLnN0dWRlbnRJZCA9PT0gc3R1ZGVudElkKTtcbn07XG5cbi8vIEVuaGFuY2VkIGZ1bmN0aW9uIHRvIGZpbmQgYXBwbGljYXRpb24gYnkgc3R1ZGVudCBJRCBvciBuYW1lIChmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSlcbmV4cG9ydCBjb25zdCBnZXRBcHBsaWNhdGlvbkJ5U3R1ZGVudCA9IChzdHVkZW50SWQ6IHN0cmluZywgc3R1ZGVudE5hbWU6IHN0cmluZyk6IFN0dWRlbnRBcHBsaWNhdGlvbiB8IHVuZGVmaW5lZCA9PiB7XG4gICAgaWYgKCFpc0Jyb3dzZXIpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYXBwbGljYXRpb25zID0gZ2V0QXBwbGljYXRpb25zKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdnZXRBcHBsaWNhdGlvbkJ5U3R1ZGVudCAtIEFsbCBhcHBsaWNhdGlvbnM6JywgYXBwbGljYXRpb25zKTtcbiAgICAgICAgY29uc29sZS5sb2coJ2dldEFwcGxpY2F0aW9uQnlTdHVkZW50IC0gTG9va2luZyBmb3Igc3R1ZGVudElkOicsIHN0dWRlbnRJZCwgJ3N0dWRlbnROYW1lOicsIHN0dWRlbnROYW1lKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEZpcnN0IHRyeSB0byBmaW5kIGJ5IGV4YWN0IHN0dWRlbnQgSURcbiAgICAgICAgbGV0IGFwcCA9IGFwcGxpY2F0aW9ucy5maW5kKGFwcCA9PiBhcHAuc3R1ZGVudElkID09PSBzdHVkZW50SWQpO1xuICAgICAgICBjb25zb2xlLmxvZygnZ2V0QXBwbGljYXRpb25CeVN0dWRlbnQgLSBGb3VuZCBieSBJRDonLCBhcHApO1xuICAgICAgICBcbiAgICAgICAgLy8gSWYgbm90IGZvdW5kLCB0cnkgdG8gZmluZCBieSBzdHVkZW50IG5hbWUgKGZvciBleGlzdGluZyBhcHBsaWNhdGlvbnMgd2l0aCBkaWZmZXJlbnQgSURzKVxuICAgICAgICBpZiAoIWFwcCkge1xuICAgICAgICAgICAgYXBwID0gYXBwbGljYXRpb25zLmZpbmQoYXBwID0+IGFwcC5zdHVkZW50TmFtZSA9PT0gc3R1ZGVudE5hbWUpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2dldEFwcGxpY2F0aW9uQnlTdHVkZW50IC0gRm91bmQgYnkgbmFtZTonLCBhcHApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBJZiBmb3VuZCBieSBuYW1lLCB1cGRhdGUgdGhlIHN0dWRlbnRJZCB0byBtYXRjaCBjdXJyZW50IHVzZXJcbiAgICAgICAgICAgIGlmIChhcHApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnZ2V0QXBwbGljYXRpb25CeVN0dWRlbnQgLSBVcGRhdGluZyBzdHVkZW50SWQgZnJvbScsIGFwcC5zdHVkZW50SWQsICd0bycsIHN0dWRlbnRJZCk7XG4gICAgICAgICAgICAgICAgYXBwLnN0dWRlbnRJZCA9IHN0dWRlbnRJZDtcbiAgICAgICAgICAgICAgICAvLyBTYXZlIHRoZSB1cGRhdGVkIGFwcGxpY2F0aW9uIGJhY2sgdG8gbG9jYWxTdG9yYWdlXG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oQVBQTElDQVRJT05TX0tFWSwgSlNPTi5zdHJpbmdpZnkoYXBwbGljYXRpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKCdnZXRBcHBsaWNhdGlvbkJ5U3R1ZGVudCAtIEZpbmFsIHJlc3VsdDonLCBhcHApO1xuICAgICAgICByZXR1cm4gYXBwO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGdldEFwcGxpY2F0aW9uQnlTdHVkZW50OicsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59O1xuXG5leHBvcnQgY29uc3QgYWRkQXBwbGljYXRpb24gPSAoYXBwbGljYXRpb246IE9taXQ8U3R1ZGVudEFwcGxpY2F0aW9uLCAnaWQnIHwgJ3N0YXR1cycgfCAnc3VibWlzc2lvbkRhdGUnPik6IFN0dWRlbnRBcHBsaWNhdGlvbiA9PiB7XG4gICAgaWYgKCFpc0Jyb3dzZXIpIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFkZCBhcHBsaWNhdGlvbiBvbiBzZXJ2ZXIgc2lkZScpO1xuICAgIGNvbnN0IGFwcGxpY2F0aW9ucyA9IGdldEFwcGxpY2F0aW9ucygpO1xuICAgIGNvbnN0IG5ld0FwcGxpY2F0aW9uOiBTdHVkZW50QXBwbGljYXRpb24gPSB7XG4gICAgICAgIC4uLmFwcGxpY2F0aW9uLFxuICAgICAgICBpZDogYGFwcF8ke0RhdGUubm93KCl9YCxcbiAgICAgICAgc3RhdHVzOiBBcHBsaWNhdGlvblN0YXR1cy5TVUJNSVRURUQsXG4gICAgICAgIHN1Ym1pc3Npb25EYXRlOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICB9O1xuICAgIGFwcGxpY2F0aW9ucy5wdXNoKG5ld0FwcGxpY2F0aW9uKTtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShBUFBMSUNBVElPTlNfS0VZLCBKU09OLnN0cmluZ2lmeShhcHBsaWNhdGlvbnMpKTtcbiAgICByZXR1cm4gbmV3QXBwbGljYXRpb247XG59O1xuXG5leHBvcnQgY29uc3QgdXBkYXRlQXBwbGljYXRpb25TdGF0dXMgPSAoYXBwbGljYXRpb25JZDogc3RyaW5nLCBzdGF0dXM6IEFwcGxpY2F0aW9uU3RhdHVzKTogU3R1ZGVudEFwcGxpY2F0aW9uIHwgdW5kZWZpbmVkID0+IHtcbiAgICBpZiAoIWlzQnJvd3NlcikgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjb25zdCBhcHBsaWNhdGlvbnMgPSBnZXRBcHBsaWNhdGlvbnMoKTtcbiAgICBjb25zdCBhcHBJbmRleCA9IGFwcGxpY2F0aW9ucy5maW5kSW5kZXgoYXBwID0+IGFwcC5pZCA9PT0gYXBwbGljYXRpb25JZCk7XG4gICAgaWYgKGFwcEluZGV4ICE9PSAtMSkge1xuICAgICAgICBhcHBsaWNhdGlvbnNbYXBwSW5kZXhdLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oQVBQTElDQVRJT05TX0tFWSwgSlNPTi5zdHJpbmdpZnkoYXBwbGljYXRpb25zKSk7XG4gICAgICAgIHJldHVybiBhcHBsaWNhdGlvbnNbYXBwSW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuZXhwb3J0IGNvbnN0IGFkZEV2YWx1YXRpb25Ob3RlVG9BcHBsaWNhdGlvbiA9IChhcHBsaWNhdGlvbklkOiBzdHJpbmcsIG5vdGU6IE9taXQ8RXZhbHVhdGlvbk5vdGUsICdpZCcgfCAndGltZXN0YW1wJz4pOiBTdHVkZW50QXBwbGljYXRpb24gfCB1bmRlZmluZWQgPT4ge1xuICAgIGlmICghaXNCcm93c2VyKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGFwcGxpY2F0aW9ucyA9IGdldEFwcGxpY2F0aW9ucygpO1xuICAgIGNvbnN0IGFwcEluZGV4ID0gYXBwbGljYXRpb25zLmZpbmRJbmRleChhcHAgPT4gYXBwLmlkID09PSBhcHBsaWNhdGlvbklkKTtcbiAgICBpZiAoYXBwSW5kZXggIT09IC0xKSB7XG4gICAgICAgIC8vIEZJWDogRXhwbGljaXRseSB0eXBlIGBuZXdOb3RlYCB0byBlbnN1cmUgaXQgbWF0Y2hlcyB0aGUgRXZhbHVhdGlvbk5vdGUgaW50ZXJmYWNlLlxuICAgICAgICBjb25zdCBuZXdOb3RlOiBFdmFsdWF0aW9uTm90ZSA9IHtcbiAgICAgICAgICAgIC4uLm5vdGUsXG4gICAgICAgICAgICBpZDogYG5vdGVfJHtEYXRlLm5vdygpfWAsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICB9O1xuICAgICAgICBpZiAoIWFwcGxpY2F0aW9uc1thcHBJbmRleF0ubm90ZXMpIHtcbiAgICAgICAgICAgIGFwcGxpY2F0aW9uc1thcHBJbmRleF0ubm90ZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBhcHBsaWNhdGlvbnNbYXBwSW5kZXhdLm5vdGVzPy5wdXNoKG5ld05vdGUpO1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShBUFBMSUNBVElPTlNfS0VZLCBKU09OLnN0cmluZ2lmeShhcHBsaWNhdGlvbnMpKTtcbiAgICAgICAgcmV0dXJuIGFwcGxpY2F0aW9uc1thcHBJbmRleF07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG5leHBvcnQgY29uc3QgZGVsZXRlQXBwbGljYXRpb24gPSAoYXBwbGljYXRpb25JZDogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gICAgaWYgKCFpc0Jyb3dzZXIpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBhcHBsaWNhdGlvbnMgPSBnZXRBcHBsaWNhdGlvbnMoKTtcbiAgICBjb25zdCBmaWx0ZXJlZEFwcGxpY2F0aW9ucyA9IGFwcGxpY2F0aW9ucy5maWx0ZXIoYXBwID0+IGFwcC5pZCAhPT0gYXBwbGljYXRpb25JZCk7XG4gICAgaWYgKGZpbHRlcmVkQXBwbGljYXRpb25zLmxlbmd0aCA8IGFwcGxpY2F0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oQVBQTElDQVRJT05TX0tFWSwgSlNPTi5zdHJpbmdpZnkoZmlsdGVyZWRBcHBsaWNhdGlvbnMpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbmV4cG9ydCBjb25zdCBjbGVhckFsbERhdGEgPSAoKTogdm9pZCA9PiB7XG4gICAgaWYgKCFpc0Jyb3dzZXIpIHJldHVybjtcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShVU0VSU19LRVkpO1xuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKEFQUExJQ0FUSU9OU19LRVkpO1xuICAgIC8vIFJlLXNlZWQgdGhlIGJhc2ljIHVzZXJzXG4gICAgc2VlZEFkbWluKCk7XG4gICAgc2VlZFN0dWRlbnQoKTtcbn07XG5cbi8vIE1pZ3JhdGlvbiBmdW5jdGlvbiB0byBmaXggZXhpc3RpbmcgYXBwbGljYXRpb25zIHdpdGggbWlzbWF0Y2hlZCBzdHVkZW50IElEc1xuZXhwb3J0IGNvbnN0IG1pZ3JhdGVBcHBsaWNhdGlvblN0dWRlbnRJZHMgPSAoKTogdm9pZCA9PiB7XG4gICAgaWYgKCFpc0Jyb3dzZXIpIHJldHVybjtcbiAgICBcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBhcHBsaWNhdGlvbnMgPSBnZXRBcHBsaWNhdGlvbnMoKTtcbiAgICAgICAgY29uc3QgdXNlcnMgPSBnZXRVc2VycygpO1xuICAgICAgICBsZXQgdXBkYXRlZCA9IGZhbHNlO1xuICAgICAgICBcbiAgICAgICAgYXBwbGljYXRpb25zLmZvckVhY2goYXBwID0+IHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBzdHVkZW50SWQgaW4gdGhlIGFwcGxpY2F0aW9uIG1hdGNoZXMgYW55IGV4aXN0aW5nIHVzZXJcbiAgICAgICAgICAgIGNvbnN0IHVzZXJFeGlzdHMgPSB1c2Vycy5maW5kKHVzZXIgPT4gdXNlci5pZCA9PT0gYXBwLnN0dWRlbnRJZCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICghdXNlckV4aXN0cykge1xuICAgICAgICAgICAgICAgIC8vIFRyeSB0byBmaW5kIHVzZXIgYnkgbmFtZVxuICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJCeU5hbWUgPSB1c2Vycy5maW5kKHVzZXIgPT4gdXNlci5mdWxsTmFtZSA9PT0gYXBwLnN0dWRlbnROYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAodXNlckJ5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBhcHAuc3R1ZGVudElkID0gdXNlckJ5TmFtZS5pZDtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGlmICh1cGRhdGVkKSB7XG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShBUFBMSUNBVElPTlNfS0VZLCBKU09OLnN0cmluZ2lmeShhcHBsaWNhdGlvbnMpKTtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIG1pZ3JhdGlvbjonLCBlcnJvcik7XG4gICAgfVxufTtcblxuLy8gU2VlZGluZyBmdW5jdGlvbnMgKGRlZmluZWQgYWZ0ZXIgbWFpbiBmdW5jdGlvbnMgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jeSlcbmNvbnN0IHNlZWRBZG1pbiA9ICgpID0+IHtcbiAgICBpZiAoIWlzQnJvd3NlcikgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IHVzZXJzID0gZ2V0VXNlcnMoKTtcbiAgICBpZiAoIXVzZXJzLnNvbWUodSA9PiB1LnJvbGUgPT09IFVzZXJSb2xlLkFETUlOKSkge1xuICAgICAgICBjb25zdCBhZG1pbjogVXNlciA9IHtcbiAgICAgICAgICAgIGlkOiAnYWRtaW5fMDEnLFxuICAgICAgICAgICAgZW1haWw6ICdhZG1pbkB0ZXN0LmNvbScsXG4gICAgICAgICAgICBwYXNzd29yZDogJ2FkbWluMTIzJyxcbiAgICAgICAgICAgIHJvbGU6IFVzZXJSb2xlLkFETUlOLFxuICAgICAgICAgICAgZnVsbE5hbWU6ICdIUCBBZG1pbidcbiAgICAgICAgfTtcbiAgICAgICAgdXNlcnMucHVzaChhZG1pbik7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFVTRVJTX0tFWSwgSlNPTi5zdHJpbmdpZnkodXNlcnMpKTtcbiAgICB9XG59O1xuXG5jb25zdCBzZWVkU3R1ZGVudCA9ICgpID0+IHtcbiAgICBpZiAoIWlzQnJvd3NlcikgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IHVzZXJzID0gZ2V0VXNlcnMoKTtcbiAgICBpZiAoIXVzZXJzLnNvbWUodSA9PiB1LmVtYWlsID09PSAnc3R1ZGVudEB0ZXN0LmNvbScpKSB7XG4gICAgICAgIGNvbnN0IHN0dWRlbnQ6IFVzZXIgPSB7XG4gICAgICAgICAgICBpZDogJ3N0dWRlbnRfMDEnLFxuICAgICAgICAgICAgZW1haWw6ICdzdHVkZW50QHRlc3QuY29tJyxcbiAgICAgICAgICAgIHBhc3N3b3JkOiAnc3R1ZGVudDEyMycsXG4gICAgICAgICAgICByb2xlOiBVc2VyUm9sZS5TVFVERU5ULFxuICAgICAgICAgICAgZnVsbE5hbWU6ICdUZXN0IFN0dWRlbnQnLFxuICAgICAgICAgICAgY29sbGVnZTogJ1Rlc3QgVW5pdmVyc2l0eSdcbiAgICAgICAgfTtcbiAgICAgICAgdXNlcnMucHVzaChzdHVkZW50KTtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oVVNFUlNfS0VZLCBKU09OLnN0cmluZ2lmeSh1c2VycykpO1xuICAgIH1cbn07XG5cbi8vIEluaXRpYWxpemUgd2l0aCBhZG1pbiBhbmQgc3R1ZGVudCAob25seSBpbiBicm93c2VyKVxuaWYgKGlzQnJvd3Nlcikge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICghbG9jYWxTdG9yYWdlLmdldEl0ZW0oVVNFUlNfS0VZKSkge1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oVVNFUlNfS0VZLCBKU09OLnN0cmluZ2lmeShbXSkpO1xuICAgICAgICAgICAgc2VlZEFkbWluKCk7XG4gICAgICAgICAgICBzZWVkU3R1ZGVudCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRW5zdXJlIGJvdGggdXNlcnMgZXhpc3QgZXZlbiBpZiBsb2NhbFN0b3JhZ2UgYWxyZWFkeSBoYXMgZGF0YVxuICAgICAgICAgICAgc2VlZEFkbWluKCk7XG4gICAgICAgICAgICBzZWVkU3R1ZGVudCgpO1xuICAgICAgICAgICAgLy8gUnVuIG1pZ3JhdGlvbiB0byBmaXggYW55IGV4aXN0aW5nIGFwcGxpY2F0aW9uIHN0dWRlbnQgSUQgbWlzbWF0Y2hlc1xuICAgICAgICAgICAgLy8gVGVtcG9yYXJpbHkgZGlzYWJsZWQgdG8gZml4IGxvYWRpbmcgaXNzdWVcbiAgICAgICAgICAgIC8vIHRyeSB7XG4gICAgICAgICAgICAvLyAgICAgbWlncmF0ZUFwcGxpY2F0aW9uU3R1ZGVudElkcygpO1xuICAgICAgICAgICAgLy8gfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vICAgICBjb25zb2xlLmVycm9yKCdNaWdyYXRpb24gZmFpbGVkOicsIGVycm9yKTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1N0b3JhZ2Ugc2VydmljZSBpbml0aWFsaXphdGlvbiBmYWlsZWQ6JywgZXJyb3IpO1xuICAgIH1cbn0iXSwibmFtZXMiOlsiVXNlclJvbGUiLCJBcHBsaWNhdGlvblN0YXR1cyIsIlVTRVJTX0tFWSIsIkFQUExJQ0FUSU9OU19LRVkiLCJpc0Jyb3dzZXIiLCJnZXRVc2VycyIsInVzZXJzIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsIkpTT04iLCJwYXJzZSIsImdldFVzZXJCeUVtYWlsIiwiZW1haWwiLCJmaW5kIiwidXNlciIsImdldFVzZXJCeUlkIiwiaWQiLCJhZGRVc2VyIiwiRXJyb3IiLCJuZXdVc2VyIiwiRGF0ZSIsIm5vdyIsInB1c2giLCJzZXRJdGVtIiwic3RyaW5naWZ5IiwiZ2V0QXBwbGljYXRpb25zIiwiYXBwbGljYXRpb25zIiwiY29uc29sZSIsImxvZyIsInBhcnNlZCIsImdldEFwcGxpY2F0aW9uQnlTdHVkZW50SWQiLCJzdHVkZW50SWQiLCJhcHAiLCJnZXRBcHBsaWNhdGlvbkJ5U3R1ZGVudCIsInN0dWRlbnROYW1lIiwidW5kZWZpbmVkIiwiZXJyb3IiLCJhZGRBcHBsaWNhdGlvbiIsImFwcGxpY2F0aW9uIiwibmV3QXBwbGljYXRpb24iLCJzdGF0dXMiLCJTVUJNSVRURUQiLCJzdWJtaXNzaW9uRGF0ZSIsInRvSVNPU3RyaW5nIiwidXBkYXRlQXBwbGljYXRpb25TdGF0dXMiLCJhcHBsaWNhdGlvbklkIiwiYXBwSW5kZXgiLCJmaW5kSW5kZXgiLCJhZGRFdmFsdWF0aW9uTm90ZVRvQXBwbGljYXRpb24iLCJub3RlIiwibmV3Tm90ZSIsInRpbWVzdGFtcCIsIm5vdGVzIiwiZGVsZXRlQXBwbGljYXRpb24iLCJmaWx0ZXJlZEFwcGxpY2F0aW9ucyIsImZpbHRlciIsImxlbmd0aCIsImNsZWFyQWxsRGF0YSIsInJlbW92ZUl0ZW0iLCJzZWVkQWRtaW4iLCJzZWVkU3R1ZGVudCIsIm1pZ3JhdGVBcHBsaWNhdGlvblN0dWRlbnRJZHMiLCJ1cGRhdGVkIiwiZm9yRWFjaCIsInVzZXJFeGlzdHMiLCJ1c2VyQnlOYW1lIiwiZnVsbE5hbWUiLCJzb21lIiwidSIsInJvbGUiLCJBRE1JTiIsImFkbWluIiwicGFzc3dvcmQiLCJzdHVkZW50IiwiU1RVREVOVCIsImNvbGxlZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./services/storageService.ts\n"));

/***/ })

});