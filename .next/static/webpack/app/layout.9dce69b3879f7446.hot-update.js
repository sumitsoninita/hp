"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./services/storageService.ts":
/*!************************************!*\
  !*** ./services/storageService.ts ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addApplication: function() { return /* binding */ addApplication; },\n/* harmony export */   addEvaluationNoteToApplication: function() { return /* binding */ addEvaluationNoteToApplication; },\n/* harmony export */   addMeeting: function() { return /* binding */ addMeeting; },\n/* harmony export */   addNotification: function() { return /* binding */ addNotification; },\n/* harmony export */   addUser: function() { return /* binding */ addUser; },\n/* harmony export */   clearAllData: function() { return /* binding */ clearAllData; },\n/* harmony export */   deleteApplication: function() { return /* binding */ deleteApplication; },\n/* harmony export */   getApplicationByStudent: function() { return /* binding */ getApplicationByStudent; },\n/* harmony export */   getApplicationByStudentId: function() { return /* binding */ getApplicationByStudentId; },\n/* harmony export */   getApplications: function() { return /* binding */ getApplications; },\n/* harmony export */   getMeetings: function() { return /* binding */ getMeetings; },\n/* harmony export */   getMeetingsByApplication: function() { return /* binding */ getMeetingsByApplication; },\n/* harmony export */   getMeetingsByStudent: function() { return /* binding */ getMeetingsByStudent; },\n/* harmony export */   getNotifications: function() { return /* binding */ getNotifications; },\n/* harmony export */   getNotificationsByStudent: function() { return /* binding */ getNotificationsByStudent; },\n/* harmony export */   getUnreadNotificationsByStudent: function() { return /* binding */ getUnreadNotificationsByStudent; },\n/* harmony export */   getUserByEmail: function() { return /* binding */ getUserByEmail; },\n/* harmony export */   getUserById: function() { return /* binding */ getUserById; },\n/* harmony export */   getUsers: function() { return /* binding */ getUsers; },\n/* harmony export */   markAllNotificationsAsRead: function() { return /* binding */ markAllNotificationsAsRead; },\n/* harmony export */   markNotificationAsRead: function() { return /* binding */ markNotificationAsRead; },\n/* harmony export */   migrateApplicationStudentIds: function() { return /* binding */ migrateApplicationStudentIds; },\n/* harmony export */   updateApplicationStatus: function() { return /* binding */ updateApplicationStatus; },\n/* harmony export */   updateMeetingStatus: function() { return /* binding */ updateMeetingStatus; }\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/types */ \"(app-pages-browser)/./types.ts\");\n\nconst USERS_KEY = \"fff_users\";\nconst APPLICATIONS_KEY = \"fff_applications\";\nconst MEETINGS_KEY = \"fff_meetings\";\nconst NOTIFICATIONS_KEY = \"fff_notifications\";\n// Check if we're in the browser\nconst isBrowser = \"object\" !== \"undefined\";\n// User Functions\nconst getUsers = ()=>{\n    if (!isBrowser) return [];\n    const users = localStorage.getItem(USERS_KEY);\n    return users ? JSON.parse(users) : [];\n};\nconst getUserByEmail = (email)=>{\n    return getUsers().find((user)=>user.email === email);\n};\nconst getUserById = (id)=>{\n    return getUsers().find((user)=>user.id === id);\n};\nconst addUser = (user)=>{\n    if (!isBrowser) throw new Error(\"Cannot add user on server side\");\n    const users = getUsers();\n    const newUser = {\n        ...user,\n        id: \"user_\".concat(Date.now())\n    };\n    users.push(newUser);\n    localStorage.setItem(USERS_KEY, JSON.stringify(users));\n    return newUser;\n};\n// Application Functions\nconst getApplications = ()=>{\n    if (!isBrowser) return [];\n    const applications = localStorage.getItem(APPLICATIONS_KEY);\n    console.log(\"getApplications - Raw localStorage data:\", applications);\n    const parsed = applications ? JSON.parse(applications) : [];\n    console.log(\"getApplications - Parsed applications:\", parsed);\n    return parsed;\n};\nconst getApplicationByStudentId = (studentId)=>{\n    return getApplications().find((app)=>app.studentId === studentId);\n};\n// Enhanced function to find application by student ID or name (for backward compatibility)\nconst getApplicationByStudent = (studentId, studentName)=>{\n    if (!isBrowser) return undefined;\n    try {\n        const applications = getApplications();\n        console.log(\"getApplicationByStudent - All applications:\", applications);\n        console.log(\"getApplicationByStudent - Looking for studentId:\", studentId, \"studentName:\", studentName);\n        // First try to find by exact student ID\n        let app = applications.find((app)=>app.studentId === studentId);\n        console.log(\"getApplicationByStudent - Found by ID:\", app);\n        // If not found, try to find by student name (for existing applications with different IDs)\n        if (!app) {\n            app = applications.find((app)=>app.studentName === studentName);\n            console.log(\"getApplicationByStudent - Found by name:\", app);\n            // If found by name, update the studentId to match current user\n            if (app) {\n                console.log(\"getApplicationByStudent - Updating studentId from\", app.studentId, \"to\", studentId);\n                app.studentId = studentId;\n                // Save the updated application back to localStorage\n                localStorage.setItem(APPLICATIONS_KEY, JSON.stringify(applications));\n            }\n        }\n        console.log(\"getApplicationByStudent - Final result:\", app);\n        return app;\n    } catch (error) {\n        console.error(\"Error in getApplicationByStudent:\", error);\n        return undefined;\n    }\n};\nconst addApplication = (application)=>{\n    if (!isBrowser) throw new Error(\"Cannot add application on server side\");\n    const applications = getApplications();\n    const newApplication = {\n        ...application,\n        id: \"app_\".concat(Date.now()),\n        status: _types__WEBPACK_IMPORTED_MODULE_0__.ApplicationStatus.SUBMITTED,\n        submissionDate: new Date().toISOString()\n    };\n    applications.push(newApplication);\n    localStorage.setItem(APPLICATIONS_KEY, JSON.stringify(applications));\n    return newApplication;\n};\nconst updateApplicationStatus = (applicationId, status)=>{\n    if (!isBrowser) return undefined;\n    const applications = getApplications();\n    const appIndex = applications.findIndex((app)=>app.id === applicationId);\n    if (appIndex !== -1) {\n        applications[appIndex].status = status;\n        localStorage.setItem(APPLICATIONS_KEY, JSON.stringify(applications));\n        return applications[appIndex];\n    }\n    return undefined;\n};\nconst addEvaluationNoteToApplication = (applicationId, note)=>{\n    if (!isBrowser) return undefined;\n    const applications = getApplications();\n    const appIndex = applications.findIndex((app)=>app.id === applicationId);\n    if (appIndex !== -1) {\n        var _applications_appIndex_notes;\n        // FIX: Explicitly type `newNote` to ensure it matches the EvaluationNote interface.\n        const newNote = {\n            ...note,\n            id: \"note_\".concat(Date.now()),\n            timestamp: new Date().toISOString()\n        };\n        if (!applications[appIndex].notes) {\n            applications[appIndex].notes = [];\n        }\n        (_applications_appIndex_notes = applications[appIndex].notes) === null || _applications_appIndex_notes === void 0 ? void 0 : _applications_appIndex_notes.push(newNote);\n        localStorage.setItem(APPLICATIONS_KEY, JSON.stringify(applications));\n        return applications[appIndex];\n    }\n    return undefined;\n};\nconst deleteApplication = (applicationId)=>{\n    if (!isBrowser) return false;\n    const applications = getApplications();\n    const filteredApplications = applications.filter((app)=>app.id !== applicationId);\n    if (filteredApplications.length < applications.length) {\n        localStorage.setItem(APPLICATIONS_KEY, JSON.stringify(filteredApplications));\n        return true;\n    }\n    return false;\n};\nconst clearAllData = ()=>{\n    if (!isBrowser) return;\n    localStorage.removeItem(USERS_KEY);\n    localStorage.removeItem(APPLICATIONS_KEY);\n    localStorage.removeItem(MEETINGS_KEY);\n    localStorage.removeItem(NOTIFICATIONS_KEY);\n    // Re-seed the basic users\n    seedAdmin();\n    seedStudent();\n};\n// Meeting Functions\nconst getMeetings = ()=>{\n    if (!isBrowser) return [];\n    const meetings = localStorage.getItem(MEETINGS_KEY);\n    return meetings ? JSON.parse(meetings) : [];\n};\nconst getMeetingsByApplication = (applicationId)=>{\n    return getMeetings().filter((meeting)=>meeting.applicationId === applicationId);\n};\nconst getMeetingsByStudent = (studentId)=>{\n    return getMeetings().filter((meeting)=>meeting.studentId === studentId);\n};\nconst addMeeting = (meeting)=>{\n    if (!isBrowser) throw new Error(\"Cannot add meeting on server side\");\n    const meetings = getMeetings();\n    const newMeeting = {\n        ...meeting,\n        id: \"meeting_\".concat(Date.now()),\n        createdAt: new Date().toISOString()\n    };\n    meetings.push(newMeeting);\n    localStorage.setItem(MEETINGS_KEY, JSON.stringify(meetings));\n    return newMeeting;\n};\nconst updateMeetingStatus = (meetingId, status)=>{\n    if (!isBrowser) return undefined;\n    const meetings = getMeetings();\n    const meetingIndex = meetings.findIndex((meeting)=>meeting.id === meetingId);\n    if (meetingIndex !== -1) {\n        meetings[meetingIndex].status = status;\n        localStorage.setItem(MEETINGS_KEY, JSON.stringify(meetings));\n        return meetings[meetingIndex];\n    }\n    return undefined;\n};\n// Notification Functions\nconst getNotifications = ()=>{\n    if (!isBrowser) return [];\n    const notifications = localStorage.getItem(NOTIFICATIONS_KEY);\n    return notifications ? JSON.parse(notifications) : [];\n};\nconst getNotificationsByStudent = (studentId)=>{\n    return getNotifications().filter((notification)=>notification.studentId === studentId);\n};\nconst getUnreadNotificationsByStudent = (studentId)=>{\n    return getNotificationsByStudent(studentId).filter((notification)=>!notification.isRead);\n};\nconst addNotification = (notification)=>{\n    if (!isBrowser) throw new Error(\"Cannot add notification on server side\");\n    const notifications = getNotifications();\n    const newNotification = {\n        ...notification,\n        id: \"notification_\".concat(Date.now()),\n        createdAt: new Date().toISOString()\n    };\n    notifications.push(newNotification);\n    localStorage.setItem(NOTIFICATIONS_KEY, JSON.stringify(notifications));\n    return newNotification;\n};\nconst markNotificationAsRead = (notificationId)=>{\n    if (!isBrowser) return undefined;\n    const notifications = getNotifications();\n    const notificationIndex = notifications.findIndex((notification)=>notification.id === notificationId);\n    if (notificationIndex !== -1) {\n        notifications[notificationIndex].isRead = true;\n        localStorage.setItem(NOTIFICATIONS_KEY, JSON.stringify(notifications));\n        return notifications[notificationIndex];\n    }\n    return undefined;\n};\nconst markAllNotificationsAsRead = (studentId)=>{\n    if (!isBrowser) return;\n    const notifications = getNotifications();\n    notifications.forEach((notification)=>{\n        if (notification.studentId === studentId && !notification.isRead) {\n            notification.isRead = true;\n        }\n    });\n    localStorage.setItem(NOTIFICATIONS_KEY, JSON.stringify(notifications));\n};\n// Migration function to fix existing applications with mismatched student IDs\nconst migrateApplicationStudentIds = ()=>{\n    if (!isBrowser) return;\n    try {\n        const applications = getApplications();\n        const users = getUsers();\n        let updated = false;\n        applications.forEach((app)=>{\n            // Check if the studentId in the application matches any existing user\n            const userExists = users.find((user)=>user.id === app.studentId);\n            if (!userExists) {\n                // Try to find user by name\n                const userByName = users.find((user)=>user.fullName === app.studentName);\n                if (userByName) {\n                    app.studentId = userByName.id;\n                    updated = true;\n                }\n            }\n        });\n        if (updated) {\n            localStorage.setItem(APPLICATIONS_KEY, JSON.stringify(applications));\n        }\n    } catch (error) {\n        console.error(\"Error in migration:\", error);\n    }\n};\n// Seeding functions (defined after main functions to avoid circular dependency)\nconst seedAdmin = ()=>{\n    if (!isBrowser) return;\n    const users = getUsers();\n    if (!users.some((u)=>u.role === _types__WEBPACK_IMPORTED_MODULE_0__.UserRole.ADMIN)) {\n        const admin = {\n            id: \"admin_01\",\n            email: \"admin@test.com\",\n            password: \"admin123\",\n            role: _types__WEBPACK_IMPORTED_MODULE_0__.UserRole.ADMIN,\n            fullName: \"HP Admin\"\n        };\n        users.push(admin);\n        localStorage.setItem(USERS_KEY, JSON.stringify(users));\n    }\n};\nconst seedStudent = ()=>{\n    if (!isBrowser) return;\n    const users = getUsers();\n    if (!users.some((u)=>u.email === \"student@test.com\")) {\n        const student = {\n            id: \"student_01\",\n            email: \"student@test.com\",\n            password: \"student123\",\n            role: _types__WEBPACK_IMPORTED_MODULE_0__.UserRole.STUDENT,\n            fullName: \"Test Student\",\n            college: \"Test University\"\n        };\n        users.push(student);\n        localStorage.setItem(USERS_KEY, JSON.stringify(users));\n    }\n};\n// Initialize with admin and student (only in browser)\nif (isBrowser) {\n    try {\n        if (!localStorage.getItem(USERS_KEY)) {\n            localStorage.setItem(USERS_KEY, JSON.stringify([]));\n            seedAdmin();\n            seedStudent();\n        } else {\n            // Ensure both users exist even if localStorage already has data\n            seedAdmin();\n            seedStudent();\n        // Run migration to fix any existing application student ID mismatches\n        // Temporarily disabled to fix loading issue\n        // try {\n        //     migrateApplicationStudentIds();\n        // } catch (error) {\n        //     console.error('Migration failed:', error);\n        // }\n        }\n    } catch (error) {\n        console.error(\"Storage service initialization failed:\", error);\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NlcnZpY2VzL3N0b3JhZ2VTZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDc0k7QUFFdEksTUFBTUUsWUFBWTtBQUNsQixNQUFNQyxtQkFBbUI7QUFDekIsTUFBTUMsZUFBZTtBQUNyQixNQUFNQyxvQkFBb0I7QUFFMUIsZ0NBQWdDO0FBQ2hDLE1BQU1DLFlBQVksYUFBa0I7QUFFcEMsaUJBQWlCO0FBQ1YsTUFBTUMsV0FBVztJQUNwQixJQUFJLENBQUNELFdBQVcsT0FBTyxFQUFFO0lBQ3pCLE1BQU1FLFFBQVFDLGFBQWFDLE9BQU8sQ0FBQ1I7SUFDbkMsT0FBT00sUUFBUUcsS0FBS0MsS0FBSyxDQUFDSixTQUFTLEVBQUU7QUFDekMsRUFBRTtBQUVLLE1BQU1LLGlCQUFpQixDQUFDQztJQUMzQixPQUFPUCxXQUFXUSxJQUFJLENBQUNDLENBQUFBLE9BQVFBLEtBQUtGLEtBQUssS0FBS0E7QUFDbEQsRUFBRTtBQUVLLE1BQU1HLGNBQWMsQ0FBQ0M7SUFDeEIsT0FBT1gsV0FBV1EsSUFBSSxDQUFDQyxDQUFBQSxPQUFRQSxLQUFLRSxFQUFFLEtBQUtBO0FBQy9DLEVBQUU7QUFFSyxNQUFNQyxVQUFVLENBQUNIO0lBQ3BCLElBQUksQ0FBQ1YsV0FBVyxNQUFNLElBQUljLE1BQU07SUFDaEMsTUFBTVosUUFBUUQ7SUFDZCxNQUFNYyxVQUFnQjtRQUFFLEdBQUdMLElBQUk7UUFBRUUsSUFBSSxRQUFtQixPQUFYSSxLQUFLQyxHQUFHO0lBQUs7SUFDMURmLE1BQU1nQixJQUFJLENBQUNIO0lBQ1haLGFBQWFnQixPQUFPLENBQUN2QixXQUFXUyxLQUFLZSxTQUFTLENBQUNsQjtJQUMvQyxPQUFPYTtBQUNYLEVBQUU7QUFHRix3QkFBd0I7QUFDakIsTUFBTU0sa0JBQWtCO0lBQzNCLElBQUksQ0FBQ3JCLFdBQVcsT0FBTyxFQUFFO0lBQ3pCLE1BQU1zQixlQUFlbkIsYUFBYUMsT0FB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QUFnRTtZQUNoRUQ7WUFDQUM7UUFDQSxzRUFBc0U7UUFDdEUsNENBQTRDO1FBQzVDLFFBQVE7UUFDUixzQ0FBc0M7UUFDdEMsb0JBQW9CO1FBQ3BCLGlEQUFpRDtRQUNqRCxJQUFJO1FBQ1I7SUFDSixFQUFFLE9BQU94QixPQUFPO1FBQ1pULFFBQVFTLEtBQUssQ0FBQywwQ0FBMENBO0lBQzVEO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc2VydmljZXMvc3RvcmFnZVNlcnZpY2UudHM/ZjQyMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCB7IFVzZXIsIFVzZXJSb2xlLCBTdHVkZW50QXBwbGljYXRpb24sIEFwcGxpY2F0aW9uU3RhdHVzLCBFdmFsdWF0aW9uTm90ZSwgTWVldGluZ1NjaGVkdWxlLCBTdHVkZW50Tm90aWZpY2F0aW9uIH0gZnJvbSAnQC90eXBlcyc7XG5cbmNvbnN0IFVTRVJTX0tFWSA9ICdmZmZfdXNlcnMnO1xuY29uc3QgQVBQTElDQVRJT05TX0tFWSA9ICdmZmZfYXBwbGljYXRpb25zJztcbmNvbnN0IE1FRVRJTkdTX0tFWSA9ICdmZmZfbWVldGluZ3MnO1xuY29uc3QgTk9USUZJQ0FUSU9OU19LRVkgPSAnZmZmX25vdGlmaWNhdGlvbnMnO1xuXG4vLyBDaGVjayBpZiB3ZSdyZSBpbiB0aGUgYnJvd3NlclxuY29uc3QgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8vIFVzZXIgRnVuY3Rpb25zXG5leHBvcnQgY29uc3QgZ2V0VXNlcnMgPSAoKTogVXNlcltdID0+IHtcbiAgICBpZiAoIWlzQnJvd3NlcikgcmV0dXJuIFtdO1xuICAgIGNvbnN0IHVzZXJzID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oVVNFUlNfS0VZKTtcbiAgICByZXR1cm4gdXNlcnMgPyBKU09OLnBhcnNlKHVzZXJzKSA6IFtdO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldFVzZXJCeUVtYWlsID0gKGVtYWlsOiBzdHJpbmcpOiBVc2VyIHwgdW5kZWZpbmVkID0+IHtcbiAgICByZXR1cm4gZ2V0VXNlcnMoKS5maW5kKHVzZXIgPT4gdXNlci5lbWFpbCA9PT0gZW1haWwpO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldFVzZXJCeUlkID0gKGlkOiBzdHJpbmcpOiBVc2VyIHwgdW5kZWZpbmVkID0+IHtcbiAgICByZXR1cm4gZ2V0VXNlcnMoKS5maW5kKHVzZXIgPT4gdXNlci5pZCA9PT0gaWQpO1xufTtcblxuZXhwb3J0IGNvbnN0IGFkZFVzZXIgPSAodXNlcjogT21pdDxVc2VyLCAnaWQnPik6IFVzZXIgPT4ge1xuICAgIGlmICghaXNCcm93c2VyKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhZGQgdXNlciBvbiBzZXJ2ZXIgc2lkZScpO1xuICAgIGNvbnN0IHVzZXJzID0gZ2V0VXNlcnMoKTtcbiAgICBjb25zdCBuZXdVc2VyOiBVc2VyID0geyAuLi51c2VyLCBpZDogYHVzZXJfJHtEYXRlLm5vdygpfWAgfTtcbiAgICB1c2Vycy5wdXNoKG5ld1VzZXIpO1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFVTRVJTX0tFWSwgSlNPTi5zdHJpbmdpZnkodXNlcnMpKTtcbiAgICByZXR1cm4gbmV3VXNlcjtcbn07XG5cblxuLy8gQXBwbGljYXRpb24gRnVuY3Rpb25zXG5leHBvcnQgY29uc3QgZ2V0QXBwbGljYXRpb25zID0gKCk6IFN0dWRlbnRBcHBsaWNhdGlvbltdID0+IHtcbiAgICBpZiAoIWlzQnJvd3NlcikgcmV0dXJuIFtdO1xuICAgIGNvbnN0IGFwcGxpY2F0aW9ucyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKEFQUExJQ0FUSU9OU19LRVkpO1xuICAgIGNvbnNvbGUubG9nKCdnZXRBcHBsaWNhdGlvbnMgLSBSYXcgbG9jYWxTdG9yYWdlIGRhdGE6JywgYXBwbGljYXRpb25zKTtcbiAgICBjb25zdCBwYXJzZWQgPSBhcHBsaWNhdGlvbnMgPyBKU09OLnBhcnNlKGFwcGxpY2F0aW9ucykgOiBbXTtcbiAgICBjb25zb2xlLmxvZygnZ2V0QXBwbGljYXRpb25zIC0gUGFyc2VkIGFwcGxpY2F0aW9uczonLCBwYXJzZWQpO1xuICAgIHJldHVybiBwYXJzZWQ7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0QXBwbGljYXRpb25CeVN0dWRlbnRJZCA9IChzdHVkZW50SWQ6IHN0cmluZyk6IFN0dWRlbnRBcHBsaWNhdGlvbiB8IHVuZGVmaW5lZCA9PiB7XG4gICAgcmV0dXJuIGdldEFwcGxpY2F0aW9ucygpLmZpbmQoYXBwID0+IGFwcC5zdHVkZW50SWQgPT09IHN0dWRlbnRJZCk7XG59O1xuXG4vLyBFbmhhbmNlZCBmdW5jdGlvbiB0byBmaW5kIGFwcGxpY2F0aW9uIGJ5IHN0dWRlbnQgSUQgb3IgbmFtZSAoZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkpXG5leHBvcnQgY29uc3QgZ2V0QXBwbGljYXRpb25CeVN0dWRlbnQgPSAoc3R1ZGVudElkOiBzdHJpbmcsIHN0dWRlbnROYW1lOiBzdHJpbmcpOiBTdHVkZW50QXBwbGljYXRpb24gfCB1bmRlZmluZWQgPT4ge1xuICAgIGlmICghaXNCcm93c2VyKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGFwcGxpY2F0aW9ucyA9IGdldEFwcGxpY2F0aW9ucygpO1xuICAgICAgICBjb25zb2xlLmxvZygnZ2V0QXBwbGljYXRpb25CeVN0dWRlbnQgLSBBbGwgYXBwbGljYXRpb25zOicsIGFwcGxpY2F0aW9ucyk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdnZXRBcHBsaWNhdGlvbkJ5U3R1ZGVudCAtIExvb2tpbmcgZm9yIHN0dWRlbnRJZDonLCBzdHVkZW50SWQsICdzdHVkZW50TmFtZTonLCBzdHVkZW50TmFtZSk7XG4gICAgICAgIFxuICAgICAgICAvLyBGaXJzdCB0cnkgdG8gZmluZCBieSBleGFjdCBzdHVkZW50IElEXG4gICAgICAgIGxldCBhcHAgPSBhcHBsaWNhdGlvbnMuZmluZChhcHAgPT4gYXBwLnN0dWRlbnRJZCA9PT0gc3R1ZGVudElkKTtcbiAgICAgICAgY29uc29sZS5sb2coJ2dldEFwcGxpY2F0aW9uQnlTdHVkZW50IC0gRm91bmQgYnkgSUQ6JywgYXBwKTtcbiAgICAgICAgXG4gICAgICAgIC8vIElmIG5vdCBmb3VuZCwgdHJ5IHRvIGZpbmQgYnkgc3R1ZGVudCBuYW1lIChmb3IgZXhpc3RpbmcgYXBwbGljYXRpb25zIHdpdGggZGlmZmVyZW50IElEcylcbiAgICAgICAgaWYgKCFhcHApIHtcbiAgICAgICAgICAgIGFwcCA9IGFwcGxpY2F0aW9ucy5maW5kKGFwcCA9PiBhcHAuc3R1ZGVudE5hbWUgPT09IHN0dWRlbnROYW1lKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdnZXRBcHBsaWNhdGlvbkJ5U3R1ZGVudCAtIEZvdW5kIGJ5IG5hbWU6JywgYXBwKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gSWYgZm91bmQgYnkgbmFtZSwgdXBkYXRlIHRoZSBzdHVkZW50SWQgdG8gbWF0Y2ggY3VycmVudCB1c2VyXG4gICAgICAgICAgICBpZiAoYXBwKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2dldEFwcGxpY2F0aW9uQnlTdHVkZW50IC0gVXBkYXRpbmcgc3R1ZGVudElkIGZyb20nLCBhcHAuc3R1ZGVudElkLCAndG8nLCBzdHVkZW50SWQpO1xuICAgICAgICAgICAgICAgIGFwcC5zdHVkZW50SWQgPSBzdHVkZW50SWQ7XG4gICAgICAgICAgICAgICAgLy8gU2F2ZSB0aGUgdXBkYXRlZCBhcHBsaWNhdGlvbiBiYWNrIHRvIGxvY2FsU3RvcmFnZVxuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKEFQUExJQ0FUSU9OU19LRVksIEpTT04uc3RyaW5naWZ5KGFwcGxpY2F0aW9ucykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZygnZ2V0QXBwbGljYXRpb25CeVN0dWRlbnQgLSBGaW5hbCByZXN1bHQ6JywgYXBwKTtcbiAgICAgICAgcmV0dXJuIGFwcDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBnZXRBcHBsaWNhdGlvbkJ5U3R1ZGVudDonLCBlcnJvcik7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGFkZEFwcGxpY2F0aW9uID0gKGFwcGxpY2F0aW9uOiBPbWl0PFN0dWRlbnRBcHBsaWNhdGlvbiwgJ2lkJyB8ICdzdGF0dXMnIHwgJ3N1Ym1pc3Npb25EYXRlJz4pOiBTdHVkZW50QXBwbGljYXRpb24gPT4ge1xuICAgIGlmICghaXNCcm93c2VyKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhZGQgYXBwbGljYXRpb24gb24gc2VydmVyIHNpZGUnKTtcbiAgICBjb25zdCBhcHBsaWNhdGlvbnMgPSBnZXRBcHBsaWNhdGlvbnMoKTtcbiAgICBjb25zdCBuZXdBcHBsaWNhdGlvbjogU3R1ZGVudEFwcGxpY2F0aW9uID0ge1xuICAgICAgICAuLi5hcHBsaWNhdGlvbixcbiAgICAgICAgaWQ6IGBhcHBfJHtEYXRlLm5vdygpfWAsXG4gICAgICAgIHN0YXR1czogQXBwbGljYXRpb25TdGF0dXMuU1VCTUlUVEVELFxuICAgICAgICBzdWJtaXNzaW9uRGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgfTtcbiAgICBhcHBsaWNhdGlvbnMucHVzaChuZXdBcHBsaWNhdGlvbik7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oQVBQTElDQVRJT05TX0tFWSwgSlNPTi5zdHJpbmdpZnkoYXBwbGljYXRpb25zKSk7XG4gICAgcmV0dXJuIG5ld0FwcGxpY2F0aW9uO1xufTtcblxuZXhwb3J0IGNvbnN0IHVwZGF0ZUFwcGxpY2F0aW9uU3RhdHVzID0gKGFwcGxpY2F0aW9uSWQ6IHN0cmluZywgc3RhdHVzOiBBcHBsaWNhdGlvblN0YXR1cyk6IFN0dWRlbnRBcHBsaWNhdGlvbiB8IHVuZGVmaW5lZCA9PiB7XG4gICAgaWYgKCFpc0Jyb3dzZXIpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3QgYXBwbGljYXRpb25zID0gZ2V0QXBwbGljYXRpb25zKCk7XG4gICAgY29uc3QgYXBwSW5kZXggPSBhcHBsaWNhdGlvbnMuZmluZEluZGV4KGFwcCA9PiBhcHAuaWQgPT09IGFwcGxpY2F0aW9uSWQpO1xuICAgIGlmIChhcHBJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgYXBwbGljYXRpb25zW2FwcEluZGV4XS5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKEFQUExJQ0FUSU9OU19LRVksIEpTT04uc3RyaW5naWZ5KGFwcGxpY2F0aW9ucykpO1xuICAgICAgICByZXR1cm4gYXBwbGljYXRpb25zW2FwcEluZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbmV4cG9ydCBjb25zdCBhZGRFdmFsdWF0aW9uTm90ZVRvQXBwbGljYXRpb24gPSAoYXBwbGljYXRpb25JZDogc3RyaW5nLCBub3RlOiBPbWl0PEV2YWx1YXRpb25Ob3RlLCAnaWQnIHwgJ3RpbWVzdGFtcCc+KTogU3R1ZGVudEFwcGxpY2F0aW9uIHwgdW5kZWZpbmVkID0+IHtcbiAgICBpZiAoIWlzQnJvd3NlcikgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjb25zdCBhcHBsaWNhdGlvbnMgPSBnZXRBcHBsaWNhdGlvbnMoKTtcbiAgICBjb25zdCBhcHBJbmRleCA9IGFwcGxpY2F0aW9ucy5maW5kSW5kZXgoYXBwID0+IGFwcC5pZCA9PT0gYXBwbGljYXRpb25JZCk7XG4gICAgaWYgKGFwcEluZGV4ICE9PSAtMSkge1xuICAgICAgICAvLyBGSVg6IEV4cGxpY2l0bHkgdHlwZSBgbmV3Tm90ZWAgdG8gZW5zdXJlIGl0IG1hdGNoZXMgdGhlIEV2YWx1YXRpb25Ob3RlIGludGVyZmFjZS5cbiAgICAgICAgY29uc3QgbmV3Tm90ZTogRXZhbHVhdGlvbk5vdGUgPSB7XG4gICAgICAgICAgICAuLi5ub3RlLFxuICAgICAgICAgICAgaWQ6IGBub3RlXyR7RGF0ZS5ub3coKX1gLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFhcHBsaWNhdGlvbnNbYXBwSW5kZXhdLm5vdGVzKSB7XG4gICAgICAgICAgICBhcHBsaWNhdGlvbnNbYXBwSW5kZXhdLm5vdGVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgYXBwbGljYXRpb25zW2FwcEluZGV4XS5ub3Rlcz8ucHVzaChuZXdOb3RlKTtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oQVBQTElDQVRJT05TX0tFWSwgSlNPTi5zdHJpbmdpZnkoYXBwbGljYXRpb25zKSk7XG4gICAgICAgIHJldHVybiBhcHBsaWNhdGlvbnNbYXBwSW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuZXhwb3J0IGNvbnN0IGRlbGV0ZUFwcGxpY2F0aW9uID0gKGFwcGxpY2F0aW9uSWQ6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICAgIGlmICghaXNCcm93c2VyKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgYXBwbGljYXRpb25zID0gZ2V0QXBwbGljYXRpb25zKCk7XG4gICAgY29uc3QgZmlsdGVyZWRBcHBsaWNhdGlvbnMgPSBhcHBsaWNhdGlvbnMuZmlsdGVyKGFwcCA9PiBhcHAuaWQgIT09IGFwcGxpY2F0aW9uSWQpO1xuICAgIGlmIChmaWx0ZXJlZEFwcGxpY2F0aW9ucy5sZW5ndGggPCBhcHBsaWNhdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKEFQUExJQ0FUSU9OU19LRVksIEpTT04uc3RyaW5naWZ5KGZpbHRlcmVkQXBwbGljYXRpb25zKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5leHBvcnQgY29uc3QgY2xlYXJBbGxEYXRhID0gKCk6IHZvaWQgPT4ge1xuICAgIGlmICghaXNCcm93c2VyKSByZXR1cm47XG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oVVNFUlNfS0VZKTtcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShBUFBMSUNBVElPTlNfS0VZKTtcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShNRUVUSU5HU19LRVkpO1xuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKE5PVElGSUNBVElPTlNfS0VZKTtcbiAgICAvLyBSZS1zZWVkIHRoZSBiYXNpYyB1c2Vyc1xuICAgIHNlZWRBZG1pbigpO1xuICAgIHNlZWRTdHVkZW50KCk7XG59O1xuXG4vLyBNZWV0aW5nIEZ1bmN0aW9uc1xuZXhwb3J0IGNvbnN0IGdldE1lZXRpbmdzID0gKCk6IE1lZXRpbmdTY2hlZHVsZVtdID0+IHtcbiAgICBpZiAoIWlzQnJvd3NlcikgcmV0dXJuIFtdO1xuICAgIGNvbnN0IG1lZXRpbmdzID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oTUVFVElOR1NfS0VZKTtcbiAgICByZXR1cm4gbWVldGluZ3MgPyBKU09OLnBhcnNlKG1lZXRpbmdzKSA6IFtdO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldE1lZXRpbmdzQnlBcHBsaWNhdGlvbiA9IChhcHBsaWNhdGlvbklkOiBzdHJpbmcpOiBNZWV0aW5nU2NoZWR1bGVbXSA9PiB7XG4gICAgcmV0dXJuIGdldE1lZXRpbmdzKCkuZmlsdGVyKG1lZXRpbmcgPT4gbWVldGluZy5hcHBsaWNhdGlvbklkID09PSBhcHBsaWNhdGlvbklkKTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRNZWV0aW5nc0J5U3R1ZGVudCA9IChzdHVkZW50SWQ6IHN0cmluZyk6IE1lZXRpbmdTY2hlZHVsZVtdID0+IHtcbiAgICByZXR1cm4gZ2V0TWVldGluZ3MoKS5maWx0ZXIobWVldGluZyA9PiBtZWV0aW5nLnN0dWRlbnRJZCA9PT0gc3R1ZGVudElkKTtcbn07XG5cbmV4cG9ydCBjb25zdCBhZGRNZWV0aW5nID0gKG1lZXRpbmc6IE9taXQ8TWVldGluZ1NjaGVkdWxlLCAnaWQnIHwgJ2NyZWF0ZWRBdCc+KTogTWVldGluZ1NjaGVkdWxlID0+IHtcbiAgICBpZiAoIWlzQnJvd3NlcikgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYWRkIG1lZXRpbmcgb24gc2VydmVyIHNpZGUnKTtcbiAgICBjb25zdCBtZWV0aW5ncyA9IGdldE1lZXRpbmdzKCk7XG4gICAgY29uc3QgbmV3TWVldGluZzogTWVldGluZ1NjaGVkdWxlID0ge1xuICAgICAgICAuLi5tZWV0aW5nLFxuICAgICAgICBpZDogYG1lZXRpbmdfJHtEYXRlLm5vdygpfWAsXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgfTtcbiAgICBtZWV0aW5ncy5wdXNoKG5ld01lZXRpbmcpO1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKE1FRVRJTkdTX0tFWSwgSlNPTi5zdHJpbmdpZnkobWVldGluZ3MpKTtcbiAgICByZXR1cm4gbmV3TWVldGluZztcbn07XG5cbmV4cG9ydCBjb25zdCB1cGRhdGVNZWV0aW5nU3RhdHVzID0gKG1lZXRpbmdJZDogc3RyaW5nLCBzdGF0dXM6ICdzY2hlZHVsZWQnIHwgJ2NvbXBsZXRlZCcgfCAnY2FuY2VsbGVkJyk6IE1lZXRpbmdTY2hlZHVsZSB8IHVuZGVmaW5lZCA9PiB7XG4gICAgaWYgKCFpc0Jyb3dzZXIpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3QgbWVldGluZ3MgPSBnZXRNZWV0aW5ncygpO1xuICAgIGNvbnN0IG1lZXRpbmdJbmRleCA9IG1lZXRpbmdzLmZpbmRJbmRleChtZWV0aW5nID0+IG1lZXRpbmcuaWQgPT09IG1lZXRpbmdJZCk7XG4gICAgaWYgKG1lZXRpbmdJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgbWVldGluZ3NbbWVldGluZ0luZGV4XS5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKE1FRVRJTkdTX0tFWSwgSlNPTi5zdHJpbmdpZnkobWVldGluZ3MpKTtcbiAgICAgICAgcmV0dXJuIG1lZXRpbmdzW21lZXRpbmdJbmRleF07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG4vLyBOb3RpZmljYXRpb24gRnVuY3Rpb25zXG5leHBvcnQgY29uc3QgZ2V0Tm90aWZpY2F0aW9ucyA9ICgpOiBTdHVkZW50Tm90aWZpY2F0aW9uW10gPT4ge1xuICAgIGlmICghaXNCcm93c2VyKSByZXR1cm4gW107XG4gICAgY29uc3Qgbm90aWZpY2F0aW9ucyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKE5PVElGSUNBVElPTlNfS0VZKTtcbiAgICByZXR1cm4gbm90aWZpY2F0aW9ucyA/IEpTT04ucGFyc2Uobm90aWZpY2F0aW9ucykgOiBbXTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXROb3RpZmljYXRpb25zQnlTdHVkZW50ID0gKHN0dWRlbnRJZDogc3RyaW5nKTogU3R1ZGVudE5vdGlmaWNhdGlvbltdID0+IHtcbiAgICByZXR1cm4gZ2V0Tm90aWZpY2F0aW9ucygpLmZpbHRlcihub3RpZmljYXRpb24gPT4gbm90aWZpY2F0aW9uLnN0dWRlbnRJZCA9PT0gc3R1ZGVudElkKTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRVbnJlYWROb3RpZmljYXRpb25zQnlTdHVkZW50ID0gKHN0dWRlbnRJZDogc3RyaW5nKTogU3R1ZGVudE5vdGlmaWNhdGlvbltdID0+IHtcbiAgICByZXR1cm4gZ2V0Tm90aWZpY2F0aW9uc0J5U3R1ZGVudChzdHVkZW50SWQpLmZpbHRlcihub3RpZmljYXRpb24gPT4gIW5vdGlmaWNhdGlvbi5pc1JlYWQpO1xufTtcblxuZXhwb3J0IGNvbnN0IGFkZE5vdGlmaWNhdGlvbiA9IChub3RpZmljYXRpb246IE9taXQ8U3R1ZGVudE5vdGlmaWNhdGlvbiwgJ2lkJyB8ICdjcmVhdGVkQXQnPik6IFN0dWRlbnROb3RpZmljYXRpb24gPT4ge1xuICAgIGlmICghaXNCcm93c2VyKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhZGQgbm90aWZpY2F0aW9uIG9uIHNlcnZlciBzaWRlJyk7XG4gICAgY29uc3Qgbm90aWZpY2F0aW9ucyA9IGdldE5vdGlmaWNhdGlvbnMoKTtcbiAgICBjb25zdCBuZXdOb3RpZmljYXRpb246IFN0dWRlbnROb3RpZmljYXRpb24gPSB7XG4gICAgICAgIC4uLm5vdGlmaWNhdGlvbixcbiAgICAgICAgaWQ6IGBub3RpZmljYXRpb25fJHtEYXRlLm5vdygpfWAsXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgfTtcbiAgICBub3RpZmljYXRpb25zLnB1c2gobmV3Tm90aWZpY2F0aW9uKTtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShOT1RJRklDQVRJT05TX0tFWSwgSlNPTi5zdHJpbmdpZnkobm90aWZpY2F0aW9ucykpO1xuICAgIHJldHVybiBuZXdOb3RpZmljYXRpb247XG59O1xuXG5leHBvcnQgY29uc3QgbWFya05vdGlmaWNhdGlvbkFzUmVhZCA9IChub3RpZmljYXRpb25JZDogc3RyaW5nKTogU3R1ZGVudE5vdGlmaWNhdGlvbiB8IHVuZGVmaW5lZCA9PiB7XG4gICAgaWYgKCFpc0Jyb3dzZXIpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgbm90aWZpY2F0aW9ucyA9IGdldE5vdGlmaWNhdGlvbnMoKTtcbiAgICBjb25zdCBub3RpZmljYXRpb25JbmRleCA9IG5vdGlmaWNhdGlvbnMuZmluZEluZGV4KG5vdGlmaWNhdGlvbiA9PiBub3RpZmljYXRpb24uaWQgPT09IG5vdGlmaWNhdGlvbklkKTtcbiAgICBpZiAobm90aWZpY2F0aW9uSW5kZXggIT09IC0xKSB7XG4gICAgICAgIG5vdGlmaWNhdGlvbnNbbm90aWZpY2F0aW9uSW5kZXhdLmlzUmVhZCA9IHRydWU7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKE5PVElGSUNBVElPTlNfS0VZLCBKU09OLnN0cmluZ2lmeShub3RpZmljYXRpb25zKSk7XG4gICAgICAgIHJldHVybiBub3RpZmljYXRpb25zW25vdGlmaWNhdGlvbkluZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbmV4cG9ydCBjb25zdCBtYXJrQWxsTm90aWZpY2F0aW9uc0FzUmVhZCA9IChzdHVkZW50SWQ6IHN0cmluZyk6IHZvaWQgPT4ge1xuICAgIGlmICghaXNCcm93c2VyKSByZXR1cm47XG4gICAgY29uc3Qgbm90aWZpY2F0aW9ucyA9IGdldE5vdGlmaWNhdGlvbnMoKTtcbiAgICBub3RpZmljYXRpb25zLmZvckVhY2gobm90aWZpY2F0aW9uID0+IHtcbiAgICAgICAgaWYgKG5vdGlmaWNhdGlvbi5zdHVkZW50SWQgPT09IHN0dWRlbnRJZCAmJiAhbm90aWZpY2F0aW9uLmlzUmVhZCkge1xuICAgICAgICAgICAgbm90aWZpY2F0aW9uLmlzUmVhZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShOT1RJRklDQVRJT05TX0tFWSwgSlNPTi5zdHJpbmdpZnkobm90aWZpY2F0aW9ucykpO1xufTtcblxuLy8gTWlncmF0aW9uIGZ1bmN0aW9uIHRvIGZpeCBleGlzdGluZyBhcHBsaWNhdGlvbnMgd2l0aCBtaXNtYXRjaGVkIHN0dWRlbnQgSURzXG5leHBvcnQgY29uc3QgbWlncmF0ZUFwcGxpY2F0aW9uU3R1ZGVudElkcyA9ICgpOiB2b2lkID0+IHtcbiAgICBpZiAoIWlzQnJvd3NlcikgcmV0dXJuO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGFwcGxpY2F0aW9ucyA9IGdldEFwcGxpY2F0aW9ucygpO1xuICAgICAgICBjb25zdCB1c2VycyA9IGdldFVzZXJzKCk7XG4gICAgICAgIGxldCB1cGRhdGVkID0gZmFsc2U7XG4gICAgICAgIFxuICAgICAgICBhcHBsaWNhdGlvbnMuZm9yRWFjaChhcHAgPT4ge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHN0dWRlbnRJZCBpbiB0aGUgYXBwbGljYXRpb24gbWF0Y2hlcyBhbnkgZXhpc3RpbmcgdXNlclxuICAgICAgICAgICAgY29uc3QgdXNlckV4aXN0cyA9IHVzZXJzLmZpbmQodXNlciA9PiB1c2VyLmlkID09PSBhcHAuc3R1ZGVudElkKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCF1c2VyRXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgLy8gVHJ5IHRvIGZpbmQgdXNlciBieSBuYW1lXG4gICAgICAgICAgICAgICAgY29uc3QgdXNlckJ5TmFtZSA9IHVzZXJzLmZpbmQodXNlciA9PiB1c2VyLmZ1bGxOYW1lID09PSBhcHAuc3R1ZGVudE5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICh1c2VyQnlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcC5zdHVkZW50SWQgPSB1c2VyQnlOYW1lLmlkO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgaWYgKHVwZGF0ZWQpIHtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKEFQUExJQ0FUSU9OU19LRVksIEpTT04uc3RyaW5naWZ5KGFwcGxpY2F0aW9ucykpO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gbWlncmF0aW9uOicsIGVycm9yKTtcbiAgICB9XG59O1xuXG4vLyBTZWVkaW5nIGZ1bmN0aW9ucyAoZGVmaW5lZCBhZnRlciBtYWluIGZ1bmN0aW9ucyB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmN5KVxuY29uc3Qgc2VlZEFkbWluID0gKCkgPT4ge1xuICAgIGlmICghaXNCcm93c2VyKSByZXR1cm47XG4gICAgXG4gICAgY29uc3QgdXNlcnMgPSBnZXRVc2VycygpO1xuICAgIGlmICghdXNlcnMuc29tZSh1ID0+IHUucm9sZSA9PT0gVXNlclJvbGUuQURNSU4pKSB7XG4gICAgICAgIGNvbnN0IGFkbWluOiBVc2VyID0ge1xuICAgICAgICAgICAgaWQ6ICdhZG1pbl8wMScsXG4gICAgICAgICAgICBlbWFpbDogJ2FkbWluQHRlc3QuY29tJyxcbiAgICAgICAgICAgIHBhc3N3b3JkOiAnYWRtaW4xMjMnLFxuICAgICAgICAgICAgcm9sZTogVXNlclJvbGUuQURNSU4sXG4gICAgICAgICAgICBmdWxsTmFtZTogJ0hQIEFkbWluJ1xuICAgICAgICB9O1xuICAgICAgICB1c2Vycy5wdXNoKGFkbWluKTtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oVVNFUlNfS0VZLCBKU09OLnN0cmluZ2lmeSh1c2VycykpO1xuICAgIH1cbn07XG5cbmNvbnN0IHNlZWRTdHVkZW50ID0gKCkgPT4ge1xuICAgIGlmICghaXNCcm93c2VyKSByZXR1cm47XG4gICAgXG4gICAgY29uc3QgdXNlcnMgPSBnZXRVc2VycygpO1xuICAgIGlmICghdXNlcnMuc29tZSh1ID0+IHUuZW1haWwgPT09ICdzdHVkZW50QHRlc3QuY29tJykpIHtcbiAgICAgICAgY29uc3Qgc3R1ZGVudDogVXNlciA9IHtcbiAgICAgICAgICAgIGlkOiAnc3R1ZGVudF8wMScsXG4gICAgICAgICAgICBlbWFpbDogJ3N0dWRlbnRAdGVzdC5jb20nLFxuICAgICAgICAgICAgcGFzc3dvcmQ6ICdzdHVkZW50MTIzJyxcbiAgICAgICAgICAgIHJvbGU6IFVzZXJSb2xlLlNUVURFTlQsXG4gICAgICAgICAgICBmdWxsTmFtZTogJ1Rlc3QgU3R1ZGVudCcsXG4gICAgICAgICAgICBjb2xsZWdlOiAnVGVzdCBVbml2ZXJzaXR5J1xuICAgICAgICB9O1xuICAgICAgICB1c2Vycy5wdXNoKHN0dWRlbnQpO1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShVU0VSU19LRVksIEpTT04uc3RyaW5naWZ5KHVzZXJzKSk7XG4gICAgfVxufTtcblxuLy8gSW5pdGlhbGl6ZSB3aXRoIGFkbWluIGFuZCBzdHVkZW50IChvbmx5IGluIGJyb3dzZXIpXG5pZiAoaXNCcm93c2VyKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKCFsb2NhbFN0b3JhZ2UuZ2V0SXRlbShVU0VSU19LRVkpKSB7XG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShVU0VSU19LRVksIEpTT04uc3RyaW5naWZ5KFtdKSk7XG4gICAgICAgICAgICBzZWVkQWRtaW4oKTtcbiAgICAgICAgICAgIHNlZWRTdHVkZW50KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBFbnN1cmUgYm90aCB1c2VycyBleGlzdCBldmVuIGlmIGxvY2FsU3RvcmFnZSBhbHJlYWR5IGhhcyBkYXRhXG4gICAgICAgICAgICBzZWVkQWRtaW4oKTtcbiAgICAgICAgICAgIHNlZWRTdHVkZW50KCk7XG4gICAgICAgICAgICAvLyBSdW4gbWlncmF0aW9uIHRvIGZpeCBhbnkgZXhpc3RpbmcgYXBwbGljYXRpb24gc3R1ZGVudCBJRCBtaXNtYXRjaGVzXG4gICAgICAgICAgICAvLyBUZW1wb3JhcmlseSBkaXNhYmxlZCB0byBmaXggbG9hZGluZyBpc3N1ZVxuICAgICAgICAgICAgLy8gdHJ5IHtcbiAgICAgICAgICAgIC8vICAgICBtaWdyYXRlQXBwbGljYXRpb25TdHVkZW50SWRzKCk7XG4gICAgICAgICAgICAvLyB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gICAgIGNvbnNvbGUuZXJyb3IoJ01pZ3JhdGlvbiBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignU3RvcmFnZSBzZXJ2aWNlIGluaXRpYWxpemF0aW9uIGZhaWxlZDonLCBlcnJvcik7XG4gICAgfVxufSJdLCJuYW1lcyI6WyJVc2VyUm9sZSIsIkFwcGxpY2F0aW9uU3RhdHVzIiwiVVNFUlNfS0VZIiwiQVBQTElDQVRJT05TX0tFWSIsIk1FRVRJTkdTX0tFWSIsIk5PVElGSUNBVElPTlNfS0VZIiwiaXNCcm93c2VyIiwiZ2V0VXNlcnMiLCJ1c2VycyIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJKU09OIiwicGFyc2UiLCJnZXRVc2VyQnlFbWFpbCIsImVtYWlsIiwiZmluZCIsInVzZXIiLCJnZXRVc2VyQnlJZCIsImlkIiwiYWRkVXNlciIsIkVycm9yIiwibmV3VXNlciIsIkRhdGUiLCJub3ciLCJwdXNoIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsImdldEFwcGxpY2F0aW9ucyIsImFwcGxpY2F0aW9ucyIsImNvbnNvbGUiLCJsb2ciLCJwYXJzZWQiLCJnZXRBcHBsaWNhdGlvbkJ5U3R1ZGVudElkIiwic3R1ZGVudElkIiwiYXBwIiwiZ2V0QXBwbGljYXRpb25CeVN0dWRlbnQiLCJzdHVkZW50TmFtZSIsInVuZGVmaW5lZCIsImVycm9yIiwiYWRkQXBwbGljYXRpb24iLCJhcHBsaWNhdGlvbiIsIm5ld0FwcGxpY2F0aW9uIiwic3RhdHVzIiwiU1VCTUlUVEVEIiwic3VibWlzc2lvbkRhdGUiLCJ0b0lTT1N0cmluZyIsInVwZGF0ZUFwcGxpY2F0aW9uU3RhdHVzIiwiYXBwbGljYXRpb25JZCIsImFwcEluZGV4IiwiZmluZEluZGV4IiwiYWRkRXZhbHVhdGlvbk5vdGVUb0FwcGxpY2F0aW9uIiwibm90ZSIsIm5ld05vdGUiLCJ0aW1lc3RhbXAiLCJub3RlcyIsImRlbGV0ZUFwcGxpY2F0aW9uIiwiZmlsdGVyZWRBcHBsaWNhdGlvbnMiLCJmaWx0ZXIiLCJsZW5ndGgiLCJjbGVhckFsbERhdGEiLCJyZW1vdmVJdGVtIiwic2VlZEFkbWluIiwic2VlZFN0dWRlbnQiLCJnZXRNZWV0aW5ncyIsIm1lZXRpbmdzIiwiZ2V0TWVldGluZ3NCeUFwcGxpY2F0aW9uIiwibWVldGluZyIsImdldE1lZXRpbmdzQnlTdHVkZW50IiwiYWRkTWVldGluZyIsIm5ld01lZXRpbmciLCJjcmVhdGVkQXQiLCJ1cGRhdGVNZWV0aW5nU3RhdHVzIiwibWVldGluZ0lkIiwibWVldGluZ0luZGV4IiwiZ2V0Tm90aWZpY2F0aW9ucyIsIm5vdGlmaWNhdGlvbnMiLCJnZXROb3RpZmljYXRpb25zQnlTdHVkZW50Iiwibm90aWZpY2F0aW9uIiwiZ2V0VW5yZWFkTm90aWZpY2F0aW9uc0J5U3R1ZGVudCIsImlzUmVhZCIsImFkZE5vdGlmaWNhdGlvbiIsIm5ld05vdGlmaWNhdGlvbiIsIm1hcmtOb3RpZmljYXRpb25Bc1JlYWQiLCJub3RpZmljYXRpb25JZCIsIm5vdGlmaWNhdGlvbkluZGV4IiwibWFya0FsbE5vdGlmaWNhdGlvbnNBc1JlYWQiLCJmb3JFYWNoIiwibWlncmF0ZUFwcGxpY2F0aW9uU3R1ZGVudElkcyIsInVwZGF0ZWQiLCJ1c2VyRXhpc3RzIiwidXNlckJ5TmFtZSIsImZ1bGxOYW1lIiwic29tZSIsInUiLCJyb2xlIiwiQURNSU4iLCJhZG1pbiIsInBhc3N3b3JkIiwic3R1ZGVudCIsIlNUVURFTlQiLCJjb2xsZWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./services/storageService.ts\n"));

/***/ })

});